# Story 3.2: OAuth 2.0 Authentication Strategy

## Status

Implementation Complete - Ready for Integration Testing

## Story

**As a** developer,
**I want** OAuth 2.0 authentication com PKCE flow suportando Bitbucket DC,
**so that** usuários podem autenticar de forma segura sem compartilhar passwords.

## Acceptance Criteria

1. Classe `OAuth2Strategy` em `src/auth/strategies/oauth2.ts` implementa interface AuthStrategy
2. Strategy implementa OAuth 2.0 Authorization Code flow com PKCE (Proof Key for Code Exchange)
3. Strategy gera authorization URL: redirect user para Bitbucket DC `/oauth/authorize` com: client_id, redirect_uri, scope, state, code_challenge
4. Strategy tem local HTTP server (express) listening em `localhost:8080` (configurable port) para callback
5. Strategy troca authorization code por access token via POST `/oauth/token` com code_verifier
6. Strategy armazena: access_token, refresh_token, expires_at, scope
7. Strategy implementa `refreshToken()`: usa refresh_token para obter novo access_token quando expira
8. Strategy valida tokens: check expires_at, call Bitbucket `/rest/api/3/myself` endpoint para validate
9. Integration test com mock OAuth server valida: full flow, token refresh, error cases (invalid code, expired token)
10. Manual test documentation para setup com real Bitbucket DC OAuth application

## Tasks / Subtasks

- [x] Task 1: Criar classe OAuth2Strategy base implementando AuthStrategy interface (AC: 1)
  - [x] Criar arquivo `src/auth/strategies/oauth2-strategy.ts`
  - [x] Implementar class OAuth2Strategy que implementa AuthStrategy interface de `src/auth/auth-strategy.ts`
  - [x] Adicionar constructor recebendo: Config (com bitbucket_url, client_id, client_secret, redirect_uri), Logger
  - [x] Adicionar método stub `authenticate(config): Promise<Credentials>` (será implementado em Task 2)
  - [x] Adicionar método stub `refreshToken(credentials): Promise<Credentials>` (será implementado em Task 4)
  - [x] Adicionar método stub `validateCredentials(credentials): boolean` (será implementado em Task 5)
  - [x] Adicionar TSDoc comments explicando OAuth 2.0 PKCE flow

- [x] Task 2: Implementar OAuth 2.0 PKCE flow - authorization URL generation (AC: 2, 3)
  - [x] Implementar método `generatePKCEParams()` que retorna: code_verifier (random 128 char string), code_challenge (SHA256 hash of verifier, base64url encoded), state (random string para CSRF protection)
  - [x] Implementar método `generateAuthorizationURL(pkce: PKCEParams): string` que constrói URL: `${bitbucket_url}/plugins/servlet/oauth/authorize?response_type=code&client_id=${client_id}&redirect_uri=${redirect_uri}&scope=${scope}&state=${state}&code_challenge=${code_challenge}&code_challenge_method=S256`
  - [x] Scope padrão: `read:bitbucket-user read:bitbucket-work write:bitbucket-work` (configurável via Config)
  - [x] Armazenar PKCE params temporariamente (in-memory Map keyed by state) para validar callback
  - [x] Log: "Generated OAuth2 authorization URL" com state e code_challenge (não log code_verifier - segurança)

- [x] Task 3: Implementar local HTTP callback server (AC: 4)
  - [x] Instalar dependência: `npm install express @types/express`
  - [x] Implementar método `startCallbackServer(port: number): Promise<express.Application>` que inicia Express server em `localhost:${port}`
  - [x] Adicionar route `GET /callback` que recebe: code, state query params
  - [x] Validar state recebido contra state armazenado (CSRF protection) → se invalid, throw AuthenticationError
  - [x] Retrieve code_verifier usando state do Map in-memory
  - [x] Retornar HTML response: "Authentication successful! You can close this window." (user-friendly)
  - [x] Implementar método `stopCallbackServer()` para gracefully shutdown server após receber callback
  - [x] Port padrão: 8080, mas configurável via Config (config.auth.oauth2.callback_port)
  - [x] Log: "Callback server started on port ${port}", "Callback received with valid state"

- [x] Task 4: Implementar token exchange e refresh (AC: 5, 6, 7)
  - [x] Implementar método `exchangeCodeForToken(code: string, codeVerifier: string): Promise<TokenResponse>` que:
    - POST para `${bitbucket_url}/plugins/servlet/oauth/token`
    - Body: `grant_type=authorization_code&code=${code}&redirect_uri=${redirect_uri}&client_id=${client_id}&client_secret=${client_secret}&code_verifier=${codeVerifier}`
    - Headers: `Content-Type: application/x-www-form-urlencoded`
    - Parse response: { access_token, refresh_token, expires_in, token_type, scope }
  - [x] Converter expires_in (seconds) para expires_at (Date): `new Date(Date.now() + expires_in * 1000)`
  - [x] Implementar método `refreshToken(credentials: Credentials): Promise<Credentials>` que:
    - POST para `${bitbucket_url}/plugins/servlet/oauth/token`
    - Body: `grant_type=refresh_token&refresh_token=${credentials.refresh_token}&client_id=${client_id}&client_secret=${client_secret}`
    - Retorna novos credentials com updated access_token e expires_at
  - [x] Handle errors: invalid_grant (refresh token expirado), unauthorized_client (client credentials inválidos)
  - [x] Log: "Access token obtained successfully", "Access token refreshed successfully", "Refresh token expired, re-authentication required"

- [x] Task 5: Implementar token validation (AC: 8)
  - [x] Implementar método `validateCredentials(credentials: Credentials): boolean` que:
    - Check if credentials.expires_at existe e é no futuro (token não expirado)
    - Check if credentials.access_token existe e não é empty string
    - Return true se válido, false otherwise
  - [x] Implementar método `validateTokenWithBitbucket(credentials: Credentials): Promise<boolean>` que:
    - GET para `${bitbucket_url}/rest/api/3/myself` com header `Authorization: Bearer ${credentials.access_token}`
    - Se response 200 OK, token válido
    - Se response 401 Unauthorized, token inválido ou expirado
    - Log: "Token validated successfully with Bitbucket", "Token validation failed - 401 Unauthorized"
  - [x] Integrar validateTokenWithBitbucket() no método authenticate() para test token após exchange

- [x] Task 6: Implementar método authenticate() completo (AC: 2, 3, 4, 5, 8)
  - [x] Implementar método `authenticate(config: Config): Promise<Credentials>` que orquestra full OAuth2 flow:
    1. Gerar PKCE params usando generatePKCEParams()
    2. Gerar authorization URL usando generateAuthorizationURL()
    3. Start callback server usando startCallbackServer()
    4. Open browser com authorization URL (usar `open` npm package)
    5. Wait for callback (Promise que resolve quando /callback route é chamado)
    6. Exchange code for token usando exchangeCodeForToken()
    7. Validate token usando validateTokenWithBitbucket()
    8. Stop callback server
    9. Return Credentials object com: bitbucket_url, auth_method: 'oauth2', access_token, refresh_token, expires_at, scope
  - [x] Handle timeout: se callback não receber em 5 minutos, throw AuthenticationError("OAuth2 authentication timed out")
  - [x] Log cada step do flow para debugging

- [x] Task 7: Adicionar unit tests para OAuth2Strategy (AC: 9)
  - [x] Criar arquivo `tests/unit/auth/strategies/oauth2-strategy.test.ts`
  - [x] Test: generatePKCEParams() retorna code_verifier, code_challenge, state válidos
  - [x] Test: generateAuthorizationURL() constrói URL correta com todos query params
  - [x] Test: exchangeCodeForToken() chama Bitbucket token endpoint com body correto (mock fetch)
  - [x] Test: refreshToken() renova access_token quando refresh_token válido (mock fetch)
  - [x] Test: refreshToken() throws TokenExpiredError quando refresh_token inválido (mock fetch retorna 400)
  - [x] Test: validateCredentials() retorna true quando token não expirado
  - [x] Test: validateCredentials() retorna false quando expires_at no passado
  - [x] Test: validateTokenWithBitbucket() valida token com Bitbucket API (mock fetch)
  - [x] Mock fetch usando vi.mock('node-fetch')

- [x] Task 8: Adicionar integration test com mock OAuth server (AC: 9)
  - [x] Criar arquivo `tests/integration/auth/oauth2-flow.test.ts`
  - [x] Implementar MockOAuthServer usando Express que simula Bitbucket OAuth endpoints:
    - GET /plugins/servlet/oauth/authorize → retorna HTML form simulando login
    - POST /plugins/servlet/oauth/authorize → redirect para callback com authorization code
    - POST /plugins/servlet/oauth/token → retorna access_token, refresh_token
    - GET /rest/api/3/myself → retorna user info
  - [x] Test: full OAuth2 flow completo (authorize → callback → exchange → validate)
  - [x] Test: token refresh flow (simular token expirado, chamar refreshToken, validar novo token)
  - [x] Test: error cases: invalid code (token endpoint retorna 400), expired refresh token (retorna 400)
  - [x] Test: callback server timeout (simular nenhum callback em 5min, verificar AuthenticationError)

- [x] Task 9: Criar manual test documentation (AC: 10)
  - [x] Criar arquivo `docs/manual-tests/oauth2-setup.md` com:
    - Pre-requisites: Bitbucket DC instance, admin access
    - Step 1: Create OAuth 2.0 application in Bitbucket DC (`/plugins/servlet/applinks/listApplicationLinks`)
    - Step 2: Configure client_id, client_secret, redirect_uri (`http://localhost:8080/callback`)
    - Step 3: Configure MCP server config.json com OAuth2 credentials
    - Step 4: Run `bitbucket-mcp setup` e verificar browser abre authorization URL
    - Step 5: Login no Bitbucket, approve OAuth app, verificar callback success
    - Step 6: Verificar credentials armazenadas (futuro: OS keychain - Story 3.5, agora: log output)
    - Step 7: Test MCP tool `call_id` para verificar auth headers funcionam
  - [x] Screenshots ou GIFs do processo (opcional para v1.0, mas recomendado)

## Dev Notes

### Previous Story Context
[From Story 3.1]
- **AuthStrategy Interface** criada em `src/auth/auth-strategy.ts` com métodos: `authenticate()`, `refreshToken?()`, `validateCredentials()`
- **AuthManager** implementado em `src/auth/auth-manager.ts` com strategy selection e credentials lifecycle
- **Credentials Interface** definida suportando múltiplos auth methods (oauth2, pat, oauth1, basic)
- **Error Classes** criadas em `src/auth/errors.ts`: AuthenticationError, InvalidCredentialsError, TokenExpiredError
- **CredentialStorage** ainda não implementado (Story 3.5) - usar mock/stub nos testes

### OAuth 2.0 PKCE Flow Architecture
[Source: architecture/backend-architecture.md#Auth Flow (OAuth 2.0 PKCE)]

**Complete Flow Sequence:**
1. User executes `bitbucket-mcp setup` command
2. AuthManager selects OAuth2Strategy baseado em config.auth_method
3. OAuth2Strategy.authenticate() é chamado:
   - Gera PKCE params (code_verifier, code_challenge, state)
   - Constrói authorization URL com code_challenge
   - Inicia local HTTP server em localhost:8080
   - Abre browser com authorization URL
4. User faz login no Bitbucket DC e aprova OAuth app
5. Bitbucket redirects para `http://localhost:8080/callback?code=AUTH_CODE&state=STATE`
6. Callback server valida state (CSRF protection)
7. OAuth2Strategy troca authorization code por access token via POST /oauth/token com code_verifier
8. Bitbucket retorna: access_token, refresh_token, expires_in, scope
9. OAuth2Strategy valida token chamando GET /rest/api/3/myself
10. Credentials armazenadas (futuro: OS keychain via CredentialStorage)
11. Callback server é shutdown gracefully
12. Setup completo, MCP server pronto para usar

**PKCE Security:**
- PKCE (Proof Key for Code Exchange) mitiga authorization code interception attacks
- code_verifier: Random string (128 chars, cryptographically secure)
- code_challenge: SHA256(code_verifier) encoded as base64url
- code_challenge é enviado em authorization URL, code_verifier é enviado em token exchange
- Attacker que intercepta authorization code não consegue trocar por token sem code_verifier

### Tech Stack Dependencies
[Source: architecture/tech-stack.md]

**Required npm Packages:**
- **express**: ^4.18.2 - Local HTTP callback server
- **@types/express**: ^4.17.17 - TypeScript types
- **open**: ^9.1.0 - Open browser automatically
- **node-fetch**: ^3.3.0 - HTTP client (já instalado - Node 22+ built-in)
- **crypto**: Node.js built-in - SHA256 hashing para PKCE

**OAuth 2.0 Endpoints (Bitbucket DC):**
- Authorization: `${bitbucket_url}/plugins/servlet/oauth/authorize`
- Token exchange: `${bitbucket_url}/plugins/servlet/oauth/token`
- Token validation: `${bitbucket_url}/rest/api/3/myself`

### Data Models
[Source: Story 3.1#Credentials Interface]

```typescript
interface Credentials {
  bitbucket_url: string;
  auth_method: 'oauth2' | 'pat' | 'oauth1' | 'basic';
  access_token?: string;
  refresh_token?: string;
  expires_at?: Date;
  scope?: string;
  // Other auth methods...
}

interface PKCEParams {
  code_verifier: string;  // 128 chars random
  code_challenge: string; // SHA256(verifier) base64url
  state: string;          // Random string for CSRF
}

interface TokenResponse {
  access_token: string;
  refresh_token: string;
  expires_in: number;     // Seconds
  token_type: 'Bearer';
  scope: string;
}
```

### Project Structure
[Source: architecture/unified-project-structure.md]

**File Locations:**
- Implementation: `src/auth/strategies/oauth2-strategy.ts`
- Unit tests: `tests/unit/auth/strategies/oauth2-strategy.test.ts`
- Integration tests: `tests/integration/auth/oauth2-flow.test.ts`
- Manual test docs: `docs/manual-tests/oauth2-setup.md`

**Naming Conventions:**
- Class name: `OAuth2Strategy` (PascalCase)
- Methods: `authenticate()`, `refreshToken()`, `validateCredentials()` (camelCase)
- File: `oauth2-strategy.ts` (kebab-case)
- Constants: `DEFAULT_CALLBACK_PORT`, `TOKEN_ENDPOINT` (UPPER_SNAKE_CASE)

### Error Handling
[Source: architecture/coding-standards.md#Error Handling, Story 3.1#Error Handling]

**Error Classes to Use:**
```typescript
import { AuthenticationError, TokenExpiredError, InvalidCredentialsError } from '../errors.js';

// When token exchange fails
throw new AuthenticationError('OAuth2 token exchange failed: invalid_grant');

// When refresh token expired
throw new TokenExpiredError('Refresh token expired, re-authentication required');

// When credentials validation fails
throw new InvalidCredentialsError('Access token missing or invalid');
```

**Error Handling Pattern:**
- Always use try/catch em async functions
- Log errors com context (operation, input params - sanitized)
- Never log access_token, refresh_token, code_verifier (segurança)
- Rethrow typed errors (não swallow)

### Integration with AuthManager
[Source: Story 3.1#Integration Points]

**How AuthManager Uses OAuth2Strategy:**
```typescript
// In AuthManager.getAuthHeaders()
const strategy = this.selectStrategy(config); // Returns OAuth2Strategy quando auth_method='oauth2'

// First time (no credentials)
if (!credentials) {
  credentials = await strategy.authenticate(config);
  await this.storage.save(config.bitbucket_url, credentials);
}

// Check if expired
if (credentials.expires_at && new Date() >= credentials.expires_at) {
  credentials = await strategy.refreshToken(credentials);
  await this.storage.save(config.bitbucket_url, credentials);
}

// Generate auth headers
return {
  'Authorization': `Bearer ${credentials.access_token}`,
  'Content-Type': 'application/json'
};
```

### Logging Requirements
[Source: architecture/backend-architecture.md#Structured Logging]

**Structured Logging Pattern:**
```typescript
import { Logger } from '../../core/logger.js';

// In OAuth2Strategy
private logger = Logger.getInstance();

// Log events
this.logger.info('OAuth2 authorization URL generated', {
  auth_method: 'oauth2',
  bitbucket_url: config.bitbucket_url,
  state: pkceParams.state,
  code_challenge: pkceParams.code_challenge
  // NO code_verifier (sensitive)
});

this.logger.info('Access token obtained successfully', {
  auth_method: 'oauth2',
  expires_at: credentials.expires_at,
  scope: credentials.scope
  // NO access_token (sensitive)
});

this.logger.error('Token exchange failed', {
  auth_method: 'oauth2',
  error_type: 'invalid_grant',
  error_message: error.message
});
```

**Sensitive Data Sanitization:**
- NEVER log: access_token, refresh_token, code_verifier, client_secret
- DO log: state, code_challenge, expires_at, scope, error messages (não stacktrace com tokens)

### Configuration
[Source: Story 3.1#Integration Points]

**Expected Config Structure:**
```typescript
interface Config {
  bitbucket_url: string;
  auth: {
    method: 'oauth2' | 'pat' | 'oauth1' | 'basic';
    oauth2?: {
      client_id: string;
      client_secret: string;
      redirect_uri: string; // Default: 'http://localhost:8080/callback'
      callback_port: number; // Default: 8080
      scope: string; // Default: 'read:bitbucket-user read:bitbucket-work write:bitbucket-work'
      timeout_minutes: number; // Default: 5
    };
  };
}
```

### Testing

#### Testing Standards
[Source: architecture/testing-strategy.md]

**Test Framework:** Vitest with mocking
**Test File Location:** 
- Unit: `tests/unit/auth/strategies/oauth2-strategy.test.ts`
- Integration: `tests/integration/auth/oauth2-flow.test.ts`

**Coverage Requirement:** Minimum 80% coverage, CI fails below threshold

**Mock Strategy:**
```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';

// Mock fetch globally
vi.mock('node-fetch');

// Mock express server in integration tests
import express from 'express';
const mockApp = express();
```

**Test Structure Pattern:**
```typescript
describe('OAuth2Strategy', () => {
  let strategy: OAuth2Strategy;
  let mockConfig: Config;
  let mockLogger: vi.Mocked<Logger>;
  
  beforeEach(() => {
    mockConfig = {
      bitbucket_url: 'https://bitbucket.example.com',
      auth: {
        method: 'oauth2',
        oauth2: {
          client_id: 'test-client',
          client_secret: 'test-secret',
          redirect_uri: 'http://localhost:8080/callback',
          callback_port: 8080,
          scope: 'read:bitbucket-user',
          timeout_minutes: 5
        }
      }
    };
    
    mockLogger = {
      info: vi.fn(),
      error: vi.fn(),
      warn: vi.fn()
    } as any;
    
    strategy = new OAuth2Strategy(mockConfig, mockLogger);
  });
  
  describe('generatePKCEParams', () => {
    it('should generate valid PKCE parameters', () => {
      const params = strategy.generatePKCEParams();
      
      expect(params.code_verifier).toHaveLength(128);
      expect(params.code_challenge).toMatch(/^[A-Za-z0-9_-]+$/); // base64url
      expect(params.state).toHaveLength(32);
    });
  });
  
  // More tests...
});
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-16 | 1.0 | Story created from Epic 3 | SM Agent |
| 2025-10-16 | 1.1 | Story approved for development | SM Agent |
| 2025-10-16 | 1.2 | Validated and approved - no issues found | PO Agent |
| 2025-10-18 | 1.3 | Tasks 1-7 implemented and tested | Dev Agent (James) |
| 2025-10-18 | 1.4 | Tasks 8-9 implemented - Story complete | Dev Agent (James) |
| 2025-10-19 | 1.5 | OAuth2Strategy integrated into AuthManager - Implementation Complete | Dev Agent (James) |

## Dev Agent Record

This section is populated by the development agent during implementation.

### Agent Model Used

Claude 3.5 Sonnet (anthropic)

### Debug Log References

N/A - No blocking issues encountered

### Completion Notes

- Implemented OAuth2Strategy class with full PKCE support (Tasks 1-6 complete)
- All unit tests passing (17 tests, Task 7 complete)
- All integration tests passing (7 tests with mock OAuth server, Task 8 complete)
- Comprehensive manual test documentation created (Task 9 complete)
- Installed dependencies: express@^4.18.2, @types/express@^4.17.17, open@^9.1.0
- Code passes ESLint validation
- OAuth2 strategy implements AuthStrategy interface and is ready for integration with AuthManager
- Security features implemented: PKCE, CSRF protection via state parameter, sensitive data sanitization in logs

**Integration with AuthManager (2025-10-19):**
- ✅ Replaced StubStrategy with OAuth2Strategy in AuthManager (src/auth/auth-manager.ts)
- ✅ Added OAuth2Strategy import and proper instantiation
- ✅ Created convertToAuthConfig() helper method to adapt AppConfig to AuthConfig format
- ✅ Updated auth-manager tests to mock fetch for OAuth2 token refresh
- ✅ All 562 tests passing (including auth-manager OAuth2 integration tests)
- ✅ No ESLint errors
- ✅ OAuth2 authentication is now fully functional and integrated

**Definition of Done Summary:**

✅ **Requirements Met** (10/10 ACs):
- AC 1-8: Fully implemented (OAuth2Strategy class, PKCE flow, callback server, token exchange/refresh, validation)
- AC 9: Complete (unit tests + integration tests with mock OAuth server)
- AC 10: Complete (comprehensive manual test documentation)

✅ **Coding Standards**: All code adheres to project standards
- Follows TypeScript strict mode, coding standards, naming conventions
- Proper error handling with typed errors
- Structured logging with sensitive data sanitization
- TSDoc documentation for all public APIs

✅ **Testing**: All tests complete and passing
- 17 unit tests covering all methods
- 7 integration tests with mock OAuth server
- Tests cover: PKCE flow, token exchange, refresh, validation, error handling, timeout scenarios
- All existing project tests still pass (233 tests total)

✅ **Build & Lint**: All passing
- No compilation errors
- No new ESLint warnings/errors
- Dependencies properly added to package.json

✅ **Documentation**: Complete
- Comprehensive 400+ line manual test guide
- Includes setup steps, troubleshooting, security considerations
- Ready for QA team and end users

### File List

**Source Files:**
- `src/auth/strategies/oauth2-strategy.ts` - OAuth2Strategy implementation with PKCE support (850 lines)
- `src/auth/auth-manager.ts` - Updated to integrate OAuth2Strategy (removed StubStrategy placeholder)

**Test Files:**
- `tests/unit/auth/strategies/oauth2-strategy.test.ts` - Unit tests for OAuth2Strategy (17 tests passing)
- `tests/integration/auth/oauth2-flow.test.ts` - Integration tests with mock OAuth server (7 tests passing)
- `tests/unit/auth/auth-manager.test.ts` - Updated with fetch mock for OAuth2 token refresh tests (18 tests passing)

**Documentation:**
- `docs/manual-tests/oauth2-setup.md` - Comprehensive manual testing guide (400+ lines)

**Dependencies Updated:**
- `package.json` - Added express, @types/express, open dependencies

## QA Results

(To be filled by QA Agent)
