# Story 1.3: Zod Schema Generation for Validation

## Status

Approved

## Story

**As a** developer,  
**I want** schemas Zod gerados automaticamente a partir do OpenAPI spec,  
**so that** posso validar inputs de usuário em runtime com type-safety antes de chamar Bitbucket API.

## Acceptance Criteria

1. Script `scripts/generate-schemas.ts` lê `data/schemas.json` e gera schemas Zod em `src/validation/generated-schemas.ts`
2. Cada OpenAPI schema component é convertido para Zod schema equivalente (strings, numbers, objects, arrays, enums, optionals)
3. Schemas incluem validações: required fields, string formats (email, uri, date-time), number constraints (min, max), array constraints
4. Generated file é formatado com Prettier e inclui header comment "AUTO-GENERATED - DO NOT EDIT"
5. Script suporta OpenAPI $ref resolution (nested schemas)
6. Generated schemas são type-safe (TypeScript types inferidos de Zod schemas)
7. Unit tests validam: schema generation correctness, validation catches invalid inputs
8. Script pode ser re-executado (idempotent) quando OpenAPI spec atualiza

## Tasks / Subtasks

- [x] Task 1: Criar estrutura do script de geração (AC: 1, 4)
  - [x] Criar arquivo `scripts/generate-schemas.ts`
  - [x] Instalar dependência: `npm install --save zod@3.x`
  - [x] Configurar constantes: `SCHEMAS_INPUT_PATH = 'data/schemas.json'`, `OUTPUT_FILE = 'src/validation/generated-schemas.ts'`
  - [x] Implementar função `loadSchemas(path: string): Promise<Record<string, SchemaObject>>` com error handling
  - [x] Implementar função `generateHeaderComment(): string` com warning "AUTO-GENERATED - DO NOT EDIT" + timestamp
  - [x] Criar estrutura de output file com imports: `import { z } from 'zod';`

- [x] Task 2: Implementar conversão OpenAPI → Zod para tipos primitivos (AC: 2, 3)
  - [x] Criar função `convertSchemaToZod(schema: SchemaObject): string` (retorna código Zod como string)
  - [x] Criar função `convertSchemaToZod(schema: SchemaObject): string` (retorna código Zod como string)
  - [x] Implementar conversão para `string`:
    ```typescript
    // schema.type = "string"
    // Output: "z.string()"
    // Com format: schema.format = "email" → "z.string().email()"
    // Com format: schema.format = "uri" → "z.string().url()"
    // Com format: schema.format = "date-time" → "z.string().datetime()"
    // Com minLength: schema.minLength = 5 → "z.string().min(5)"
    // Com maxLength: schema.maxLength = 100 → "z.string().max(100)"
    // Com pattern: schema.pattern = "^[A-Z]+" → "z.string().regex(/^[A-Z]+/)"
    ```
  - [x] Implementar conversão para `number`:
    ```typescript
    // schema.type = "number"
    // Output: "z.number()"
    // Com minimum: schema.minimum = 0 → "z.number().min(0)"
    // Com maximum: schema.maximum = 100 → "z.number().max(100)"
    // Com multipleOf: schema.multipleOf = 5 → "z.number().multipleOf(5)"
    ```
  - [x] Implementar conversão para `integer`:
    ```typescript
    // schema.type = "integer"
    // Output: "z.number().int()"
    // Incluir validações min/max/multipleOf
    ```
  - [x] Implementar conversão para `boolean`:
    ```typescript
    // schema.type = "boolean"
    // Output: "z.boolean()"
    ```

- [x] Task 3: Implementar conversão para tipos complexos (AC: 2, 3)
  - [x] Implementar conversão para `array`:
    ```typescript
    // schema.type = "array", schema.items = { type: "string" }
    // Output: "z.array(z.string())"
    // Com minItems: schema.minItems = 1 → "z.array(z.string()).min(1)"
    // Com maxItems: schema.maxItems = 10 → "z.array(z.string()).max(10)"
    // Com uniqueItems: schema.uniqueItems = true → adicionar refine check
    ```
  - [x] Implementar conversão para `enum`:
    ```typescript
    // schema.enum = ["active", "inactive", "pending"]
    // Output: "z.enum(['active', 'inactive', 'pending'])"
    ```
  - [x] Implementar conversão para `object`:
    ```typescript
    // schema.type = "object", schema.properties = { name: {type: "string"}, age: {type: "number"} }
    // schema.required = ["name"]
    // Output: "z.object({ name: z.string(), age: z.number().optional() })"
    ```
  - [x] Implementar handling de `required` fields:
    - Se campo está em `schema.required[]` → obrigatório (sem `.optional()`)
    - Se campo NÃO está em `schema.required[]` → opcional (`.optional()`)
  - [x] Implementar handling de `additionalProperties`:
    - Se `additionalProperties: false` → `.strict()`
    - Se `additionalProperties: true` → `.passthrough()`
    - Se `additionalProperties: { schema }` → `.catchall(convertSchema(...))`

- [x] Task 4: Implementar resolução de $ref (AC: 5)
  - [x] Criar função `resolveRef(ref: string, schemas: Record<string, SchemaObject>): SchemaObject`
  - [x] Parsear string `$ref`: formato `#/components/schemas/SchemaName` → extrair "SchemaName"
  - [x] Buscar schema referenciado: `schemas[schemaName]`
  - [x] Se schema não encontrado, lançar erro: `new Error(\`Schema reference not found: ${ref}\`)`
  - [x] Implementar resolução recursiva (máximo 10 níveis de profundidade para evitar loops infinitos)
  - [x] Para schemas com $ref, gerar código Zod que referencia schema exportado:
    ```typescript
    // schema = { $ref: "#/components/schemas/User" }
    // Output: "UserSchema" (referência ao schema exportado)
    ```
  - [x] Adicionar validação: detectar referências circulares e lançar warning ou usar `z.lazy()`

- [x] Task 5: Gerar código TypeScript com exports (AC: 1, 6)
  - [x] Para cada schema em `schemas.json`, gerar export nomeado:
    ```typescript
    // Schema name: "IssueUpdateDetails"
    // Output:
    // export const IssueUpdateDetailsSchema = z.object({
    //   fields: z.object({}).passthrough(),
    //   update: z.record(z.any()).optional(),
    // });
    //
    // export type IssueUpdateDetails = z.infer<typeof IssueUpdateDetailsSchema>;
    ```
  - [x] Implementar naming convention para exports:
    - Nome do schema: `IssueUpdateDetails` → export: `IssueUpdateDetailsSchema`
    - Type inference: `export type IssueUpdateDetails = z.infer<typeof IssueUpdateDetailsSchema>`
  - [x] Concatenar todos os schemas gerados em string final
  - [x] Adicionar header comment no topo do arquivo (Task 1)
  - [x] Adicionar imports necessários: `import { z } from 'zod';`

- [x] Task 6: Formatar e salvar output file (AC: 4)
  - [x] Criar função `formatWithPrettier(code: string): Promise<string>`
  - [x] Usar Prettier API para formatar código gerado (já configurado no projeto)
  - [x] Implementar função `saveGeneratedFile(content: string, outputPath: string): Promise<void>`
  - [x] Garantir diretório `src/validation/` existe antes de salvar
  - [x] Salvar arquivo formatado em `src/validation/generated-schemas.ts`
  - [x] Log caminho completo do arquivo salvo e estatísticas (número de schemas gerados)

- [x] Task 7: Implementar CLI execution e package.json script (AC: 8)
  - [x] Adicionar script no package.json:
    ```json
    {
      "scripts": {
        "generate-schemas": "tsx scripts/generate-schemas.ts"
      }
    }
    ```
  - [x] Implementar idempotência: re-executar script deve produzir mesmo output (AC: 8)
  - [x] Adicionar flag `--help` com usage instructions
  - [x] Adicionar progress indicators: "Loading schemas...", "Generating X schemas...", "Done!"
  - [x] Implementar error handling robusto com mensagens descritivas

- [x] Task 8: Criar unit tests para conversão de schemas (AC: 7)
  - [x] Criar `tests/unit/scripts/generate-schemas.test.ts`
  - [x] Mock schemas.json com schemas de exemplo para cada tipo
  - [x] Test case: String schema com format email → gera `z.string().email()`
  - [x] Test case: Number schema com min/max → gera `z.number().min(X).max(Y)`
  - [x] Test case: Object schema com required fields → campos obrigatórios vs opcionais
  - [x] Test case: Array schema com items → gera `z.array(itemSchema)`
  - [x] Test case: Enum schema → gera `z.enum([...])`
  - [x] Test case: Schema com $ref → resolve referência corretamente
  - [x] Test case: Nested objects e arrays → hierarquia correta
  - [x] Test case: String pattern (regex) → converte para `z.string().regex()`

- [x] Task 9: Criar unit tests para validação runtime (AC: 7)
  - [x] Criar `tests/unit/validation/generated-schemas.test.ts`
  - [x] Importar schemas gerados diretamente de `src/validation/generated-schemas.ts`
  - [x] Test case: Valid input passa validação → `.parse(validInput)` não lança erro
  - [x] Test case: Missing required field → `.parse(invalidInput)` lança ZodError
  - [x] Test case: Invalid email format → `.parse({ email: 'invalid' })` lança ZodError
  - [x] Test case: Number fora de range → `.parse({ age: -5 })` lança ZodError com min/max
  - [x] Test case: Invalid enum value → lança ZodError com valores aceitos
  - [x] Test case: Type mismatch (string esperado, number fornecido) → lança ZodError
  - [x] Validar mensagens de erro são descritivas e incluem path do campo

- [x] Task 10: Validar end-to-end com schemas reais
  - [x] Executar `npm run download-openapi` para garantir `data/schemas.json` está atualizado (desambiguado via sufixos contextuais em `operationId`)
  - [x] Executar `npm run generate-schemas`
  - [x] Verificar `src/validation/generated-schemas.ts` foi criado com header comment
  - [x] Verificar file size razoável (~100-200KB para ~180 schemas)
  - [x] Inspecionar manualmente 5 schemas gerados aleatoriamente: código Zod correto?
  - [x] Compilar TypeScript: `npm run build` deve passar sem erros
  - [x] Executar linter: `npm run lint` deve passar (código gerado deve estar formatado)
  - [x] Executar unit tests: `npm test` deve passar
  - [x] Verificar type inference: imports de types funcionam em código TypeScript
  - [x] Commit `src/validation/generated-schemas.ts` no repo (é fonte gerada, mas commitada para review)

## Dev Notes

### Previous Story Context

**Story 1.2 - OpenAPI Spec Download & Parsing:**
- Script `scripts/download-openapi.ts` implementado e testado
- Arquivo `data/operations.json` gerado com ~500 operations
- Arquivo `data/schemas.json` gerado com ~180 OpenAPI schemas (AC: 6 da Story 1.2)
- Schemas extraídos incluem estrutura completa: type, properties, required, enum, format, constraints
- Schemas podem ter $ref references que precisam ser resolvidos

### OpenAPI to Zod Conversion Strategy

[Source: docs/prd/epic-1-foundation-semantic-search-engine.md#story-1.3]

Esta história converte os schemas OpenAPI extraídos na Story 1.2 para schemas Zod que permitem validação runtime com type-safety.

**Objetivo:** Criar arquivo `src/validation/generated-schemas.ts` com schemas Zod exportados que podem ser:
- Importados em código TypeScript: `import { IssueUpdateDetailsSchema } from './validation/generated-schemas.js'`
- Usados para validação runtime: `schema.parse(userInput)` lança ZodError se inválido
- Usados para type inference: `type IssueUpdateDetails = z.infer<typeof IssueUpdateDetailsSchema>`

**Key Decisions:**
- Generated file é commitado no repo (não .gitignored) para code review e easy inspection
- File tem header comment "AUTO-GENERATED - DO NOT EDIT" para evitar edições manuais
- Schema names seguem convenção: `IssueUpdateDetails` → `IssueUpdateDetailsSchema`
- $ref references são resolvidas e convertidas para referências TypeScript entre schemas

### Tech Stack Specifics

[Source: docs/architecture/tech-stack.md]

**Biblioteca principal para esta história:**
- `zod@3.x`: Runtime validation com type inference (z.infer<>)

**Rationale - Por que Zod ao invés de AJV:**
- Type inference: `z.infer<typeof schema>` gera TypeScript types automaticamente
- Developer experience: Errors mais legíveis, API composable
- Runtime safety: Valida e transforma inputs com parse/safeParse
- Trade-off: AJV é ~3x mais rápido em benchmarks, mas Zod é "fast enough" (<1ms validation)

**Outras dependências utilizadas:**
- `tsx`: Para executar script TypeScript diretamente (npm run generate-schemas)
- `prettier`: Para formatar código gerado automaticamente

### Project Structure

[Source: docs/architecture/unified-project-structure.md]

**Localização dos arquivos:**
```
scripts/
└── generate-schemas.ts      # Este script (novo)
src/validation/
└── generated-schemas.ts      # Output gerado (novo, commitado)
data/
└── schemas.json              # Input (gerado por Story 1.2)
tests/unit/scripts/
└── generate-schemas.test.ts  # Unit tests conversão (novo)
tests/unit/validation/
└── generated-schemas.test.ts # Unit tests validação runtime (novo)
```

**Key Decision:** `src/validation/generated-schemas.ts` é **commitado** no repositório (diferente de outros generated files). Rationale:
- Facilita code review: developers podem ver mudanças quando OpenAPI spec atualiza
- Self-documenting: file mostra estrutura dos schemas Bitbucket sem precisar ler JSON
- Type checking: TypeScript pode validar uso correto dos schemas durante compilação
- Tamanho gerenciável: ~100-200KB (compressível no Git)

### OpenAPI to Zod Mapping Rules

[Source: docs/prd/epic-1-foundation-semantic-search-engine.md#story-1.3, AC2-3]

**Mapeamento de tipos primitivos:**

| OpenAPI Type | OpenAPI Format | Zod Equivalent | Example |
|--------------|----------------|----------------|---------|
| `string` | (none) | `z.string()` | `z.string()` |
| `string` | `email` | `z.string().email()` | `z.string().email()` |
| `string` | `uri` | `z.string().url()` | `z.string().url()` |
| `string` | `date-time` | `z.string().datetime()` | `z.string().datetime()` |
| `number` | (none) | `z.number()` | `z.number()` |
| `integer` | (none) | `z.number().int()` | `z.number().int()` |
| `boolean` | (none) | `z.boolean()` | `z.boolean()` |

**Constraints mapping:**

| OpenAPI Constraint | Zod Method | Example |
|--------------------|------------|---------|
| `minLength: 5` | `.min(5)` | `z.string().min(5)` |
| `maxLength: 100` | `.max(100)` | `z.string().max(100)` |
| `pattern: "^[A-Z]+"` | `.regex(/^[A-Z]+/)` | `z.string().regex(/^[A-Z]+/)` |
| `minimum: 0` | `.min(0)` | `z.number().min(0)` |
| `maximum: 100` | `.max(100)` | `z.number().max(100)` |
| `multipleOf: 5` | `.multipleOf(5)` | `z.number().multipleOf(5)` |
| `minItems: 1` | `.min(1)` | `z.array(z.string()).min(1)` |
| `maxItems: 10` | `.max(10)` | `z.array(z.string()).max(10)` |
| `enum: ["a", "b"]` | `z.enum(["a", "b"])` | `z.enum(['active', 'inactive'])` |

**Complex types mapping:**

```typescript
// OpenAPI: { type: "object", properties: { name: { type: "string" }, age: { type: "number" } }, required: ["name"] }
// Zod:
z.object({
  name: z.string(),
  age: z.number().optional()
})

// OpenAPI: { type: "array", items: { type: "string" } }
// Zod:
z.array(z.string())

// OpenAPI: { $ref: "#/components/schemas/User" }
// Zod:
UserSchema // Referência ao schema exportado
```

**Required vs Optional fields:**
- Se campo está em `schema.required[]` → campo obrigatório (sem `.optional()`)
- Se campo NÃO está em `schema.required[]` → campo opcional (`.optional()`)

### $ref Resolution Strategy

[Source: docs/prd/epic-1-foundation-semantic-search-engine.md#story-1.3, AC5]

OpenAPI schemas podem ter `$ref` references para outros schemas:

```json
{
  "IssueUpdateDetails": {
    "type": "object",
    "properties": {
      "fields": { "$ref": "#/components/schemas/IssueFields" }
    }
  }
}
```

**Resolution Algorithm:**
1. Parse `$ref` string: `#/components/schemas/SchemaName` → extrair "SchemaName"
2. Lookup schema: `schemas["SchemaName"]`
3. Se encontrado, gerar código que referencia schema exportado: `IssueFieldsSchema`
4. Se não encontrado, lançar erro descritivo
5. Detectar referências circulares (A → B → A): usar `z.lazy(() => ASchema)` ou lançar warning

**Generated code example:**

```typescript
// Input schemas.json:
// {
//   "IssueFields": { "type": "object", "properties": { "summary": { "type": "string" } } },
//   "IssueUpdateDetails": { "type": "object", "properties": { "fields": { "$ref": "#/components/schemas/IssueFields" } } }
// }

// Generated output:
export const IssueFieldsSchema = z.object({
  summary: z.string().optional()
});

export type IssueFields = z.infer<typeof IssueFieldsSchema>;

export const IssueUpdateDetailsSchema = z.object({
  fields: IssueFieldsSchema.optional() // Referência resolvida
});

export type IssueUpdateDetails = z.infer<typeof IssueUpdateDetailsSchema>;
```

### Coding Standards

[Source: docs/architecture/coding-standards.md]

**Aplicáveis a esta história:**
- **Type Safety:** Código gerado deve ser type-safe (strict TypeScript, sem any)
- **No Console.log:** Usar console.log apenas para progress indicators (exception permitida para scripts)
- **Async/Await:** Função loadSchemas() deve ser async
- **Error Handling:** try/catch em todas as funções I/O (file read, file write)
- **Immutability:** Usar const, Array.map() ao invés de mutations
- **Test Coverage:** 100% coverage para conversion logic (crítico para correctness)
- **Documentation:** TSDoc comments para funções principais (convertSchemaToZod, resolveRef)

**Naming Conventions:**
- Functions: camelCase (convertSchemaToZod, loadSchemas)
- Constants: UPPER_SNAKE_CASE (SCHEMAS_INPUT_PATH, OUTPUT_FILE)
- Generated exports: PascalCase + "Schema" suffix (IssueUpdateDetailsSchema)
- Files: kebab-case (generate-schemas.ts)

### Testing Requirements

[Source: docs/architecture/testing-strategy.md]

**Test Organization:**
```
tests/unit/scripts/
└── generate-schemas.test.ts    # Tests para conversion logic
tests/unit/validation/
└── generated-schemas.test.ts   # Tests para runtime validation
```

**Test Coverage Requirements:**
- Conversion logic: 100% (crítico, erros propagam para validação runtime)
- Mock schemas.json com casos edge: empty objects, deeply nested, circular refs
- Validação runtime: Testar que schemas gerados validam corretamente

**Mock OpenAPI Schema (minimal válido para tests):**
```typescript
const mockSchemas = {
  "SimpleString": {
    "type": "string",
    "minLength": 5,
    "maxLength": 100
  },
  "EmailField": {
    "type": "string",
    "format": "email"
  },
  "UserObject": {
    "type": "object",
    "properties": {
      "name": { "type": "string" },
      "age": { "type": "integer", "minimum": 0, "maximum": 150 }
    },
    "required": ["name"]
  },
  "StatusEnum": {
    "type": "string",
    "enum": ["active", "inactive", "pending"]
  },
  "IssueArray": {
    "type": "array",
    "items": { "type": "string" },
    "minItems": 1,
    "maxItems": 10
  },
  "NestedRef": {
    "type": "object",
    "properties": {
      "user": { "$ref": "#/components/schemas/UserObject" }
    }
  }
};
```

**Test Cases (mínimo):**
1. String com minLength/maxLength → `z.string().min(5).max(100)`
2. String com format email → `z.string().email()`
3. Number com min/max → `z.number().min(0).max(100)`
4. Integer → `z.number().int()`
5. Object com required fields → campos opcionais vs obrigatórios
6. Array com constraints → `z.array().min(1).max(10)`
7. Enum → `z.enum(['active', 'inactive', 'pending'])`
8. $ref resolution → referência correta ao schema importado
9. Valid input passa validação runtime
10. Invalid input lança ZodError com mensagem descritiva

**Test Execution:**
```bash
npm test -- tests/unit/scripts/generate-schemas.test.ts
npm test -- tests/unit/validation/generated-schemas.test.ts
```

### TypeScript Types

```typescript
import { OpenAPIV3 } from 'openapi3-ts';

type SchemaObject = OpenAPIV3.SchemaObject;

interface GenerationOptions {
  inputPath: string;
  outputPath: string;
  prettierConfig?: object;
}

interface ConversionContext {
  schemas: Record<string, SchemaObject>;
  resolvedRefs: Set<string>; // Track para detectar circular refs
}

// Output structure
interface GeneratedSchema {
  name: string; // "IssueUpdateDetails"
  schemaCode: string; // "z.object({ ... })"
  typeCode: string; // "export type IssueUpdateDetails = z.infer<typeof IssueUpdateDetailsSchema>"
}
```

### Error Handling Strategy

[Source: docs/architecture/coding-standards.md]

**Custom Error Classes:**
```typescript
class SchemaNotFoundError extends Error {
  constructor(ref: string) {
    super(`Schema reference not found: ${ref}`);
    this.name = 'SchemaNotFoundError';
  }
}

class CircularReferenceError extends Error {
  constructor(chain: string[]) {
    super(`Circular reference detected: ${chain.join(' → ')}`);
    this.name = 'CircularReferenceError';
  }
}

class UnsupportedSchemaTypeError extends Error {
  constructor(type: string, schemaName: string) {
    super(`Unsupported schema type '${type}' in schema '${schemaName}'`);
    this.name = 'UnsupportedSchemaTypeError';
  }
}
```

**Error Handling Pattern:**
```typescript
try {
  const schemas = await loadSchemas(inputPath);
  const generatedCode = generateZodSchemas(schemas);
  await saveGeneratedFile(generatedCode, outputPath);
  console.log(`✓ Generated ${Object.keys(schemas).length} Zod schemas`);
} catch (error) {
  if (error instanceof SchemaNotFoundError) {
    console.error('Schema reference error:', error.message);
    console.error('Check that all $ref references exist in schemas.json');
  } else if (error instanceof CircularReferenceError) {
    console.error('Circular reference error:', error.message);
    console.error('Consider using z.lazy() for recursive schemas');
  } else {
    console.error('Unexpected error:', error);
  }
  process.exit(1);
}
```

### Package.json Dependencies

```json
{
  "dependencies": {
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "openapi3-ts": "^4.1.2",
    "tsx": "^4.7.0",
    "prettier": "^3.1.0"
  }
}
```

**Rationale:**
- `zod`: Runtime validation + type inference (production dependency)
- `openapi3-ts`: TypeScript types para OpenAPI schemas (dev dependency, já instalado em Story 1.2)
- `tsx`: Execute TypeScript scripts diretamente
- `prettier`: Format generated code (já instalado em Story 1.1)

### Example CLI Usage

```bash
# Generate Zod schemas from OpenAPI schemas
npm run generate-schemas

# Show help
npm run generate-schemas -- --help

# Expected output:
# Loading schemas from data/schemas.json...
# Found 187 schemas
# Generating Zod schemas...
# Formatting with Prettier...
# ✓ Generated 187 Zod schemas → src/validation/generated-schemas.ts
# File size: 156KB
```

### Success Criteria Validation

Após Task 10, validar:
- [x] `src/validation/generated-schemas.ts` existe com header "AUTO-GENERATED"
- [x] File contém ~180+ exported schemas (um por OpenAPI schema)
- [x] Cada schema tem export: `export const XSchema = z.object({...})`
- [x] Cada schema tem type inference: `export type X = z.infer<typeof XSchema>`
- [x] Código está formatado com Prettier (indentação consistente)
- [x] TypeScript compila sem erros: `npm run build`
- [x] Linter passa: `npm run lint`
- [x] Unit tests passam com 100% coverage para conversion logic
- [x] Runtime validation funciona: invalid inputs lançam ZodError

## Testing

### Test File Location

[Source: docs/architecture/testing-strategy.md]

- Conversion tests: `tests/unit/scripts/generate-schemas.test.ts`
- Runtime validation tests: `tests/unit/validation/generated-schemas.test.ts`
- Naming: `*.test.ts` suffix
- Organization: Espelha structure de `scripts/` e `src/validation/`

### Test Standards

- Framework: Vitest
- Coverage provider: v8
- Minimum coverage: 100% para conversion logic (data-critical)
- Mock external dependencies: fs/promises para file I/O

### Testing Frameworks and Patterns

- Vitest API: `describe`, `it`, `expect`, `beforeEach`, `vi.mock()`
- Imports: usar `.js` extension (ESM requirement)
- Mocking: `vi.fn()` para funções, `vi.mocked()` para modules

### Specific Testing Requirements for Story 1.3

1. **Mock Schemas (minimal):** Create mock schemas.json com 6 schema types
2. **Conversion Tests:** Validate cada tipo OpenAPI → Zod correto
3. **Resolution Tests:** Validate $ref references são resolvidas
4. **Validation Tests:** Validate schemas gerados validam corretamente em runtime
5. **Error Handling Tests:** Validate custom errors são lançados

**Test Execution:**
```bash
# Run only conversion tests
npm test -- tests/unit/scripts/generate-schemas.test.ts

# Run only validation tests
npm test -- tests/unit/validation/generated-schemas.test.ts

# Run with coverage
npm run test:coverage

# Watch mode during development
npm test -- --watch
```

**Coverage Assertion:** CI deve falhar se coverage < 100% para `scripts/generate-schemas.ts`.

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-15 | 1.0 | Initial story creation | Bob (Scrum Master) |
| 2025-01-15 | 1.1 | Story approved after validation checklist - status changed to Approved | Bob (Scrum Master) |
| 2025-10-16 | 1.2 | Story validation completed - Zero critical issues found, Implementation Readiness Score: 10/10, Status: GO | Sarah (Product Owner) |
| 2025-10-16 | 1.3 | Re-validation completed: All 8 ACs properly mapped, OpenAPI→Zod conversion rules validated, $ref resolution strategy confirmed, type safety verified. Implementation Readiness Score: 10/10. Status: APPROVED | GitHub Copilot (AI Assistant) |
| 2025-10-17 | 1.4 | Implementação concluída: gerador de schemas Zod com suporte a recursão, testes unitários adicionados, download OpenAPI desambiguado (430 operações/321 schemas) e validações automatizadas executadas. | James (Dev Agent) |

## Dev Agent Record

_This section will be populated by the development agent during implementation._

### Agent Model Used

GPT-5-Codex (GitHub Copilot)

### Debug Log References

- 2025-10-16: Task 1 – Script scaffolding and dependency install completed.
- 2025-10-16: Task 8 – Conversion unit tests implemented.
- 2025-10-16: Task 9 – Runtime validation tests implemented.
- 2025-10-17: Task 2 – Conversão recursiva ajustada para schemas auto-referenciados com `z.lazy` tipado.
- 2025-10-17: Task 10 – Download oficial do OpenAPI bem-sucedido após desambiguação de `operationId`; dados regenerados (430 operações / 321 schemas) e build/lint/test rerun.

### Completion Notes List

- Implementado gerador de schemas com suporte a auto-referências sem erros de tipo (`z.ZodTypeAny` nas definições internas).
- Adicionadas anotações de normalização que removem prefixos com hífen/underscore em `download-openapi` para reduzir colisões de `operationId`.
- `src/validation/generated-schemas.ts` regenerado com 321 schemas (≈174 KB) e validado via build/lint/test.
- Download do OpenAPI estabilizado via sufixos contextuais; dataset atualizado (operations.json/schemas.json) alinhado à versão 11.0.1 (430 operações, 321 schemas).

### File List

- scripts/generate-schemas.ts (added)
- package.json (modified)
- package-lock.json (modified)
- docs/stories/1.3.zod-schema-generation.md (modified)
- tests/unit/scripts/generate-schemas.test.ts (added)
- tests/unit/validation/generated-schemas.test.ts (added)
- src/validation/generated-schemas.ts (generated)
- scripts/download-openapi.ts (modified)
- data/operations.json (regenerated)
- data/schemas.json (regenerated)

## QA Results

_This section will be populated by QA Agent after story implementation is complete._

