# Story 2.4: Bitbucket API Client Service

## Status

Ready for Review

## Story

**As a** developer,  
**I want** service que encapsula HTTP calls para Bitbucket DC REST API com error handling robusto,  
**so that** posso executar operations Bitbucket de forma confiável com retries e rate limiting.

## Prerequisites

**Dependencies que devem existir antes de implementar esta história:**

- ✅ `AuthManager` (`src/auth/auth-manager.ts`) - para obter auth headers
- ✅ `RateLimiter` (`src/core/rate-limiter.ts`) - para token bucket rate limiting
- ✅ `Logger` (`src/core/logger.ts`) - para structured logging
- ✅ `Config` (`src/core/config-manager.ts`) - para configurações (bitbucket_url, timeouts)
- ✅ `EmbeddingsRepository` (`src/data/embeddings-repository.ts`) - para buscar operation metadata

**Nota:** Se alguma dependency não existir, ela precisa ser implementada primeiro ou stub para testes.

## Acceptance Criteria

1. Classe `BitbucketClientService` em `src/services/bitbucket-client.ts` implementada
2. Service tem método `executeOperation(operationId, params)` que constrói HTTP request baseado em operation metadata
3. Service usa node-fetch (ou axios) para HTTP calls
4. Service implementa rate limiting: max 100 req/s (configurable), usa token bucket algorithm
5. Service implementa retry logic: 3 retries com exponential backoff (100ms, 500ms, 2s) para errors transientes (timeout, 429, 5xx)
6. Service implementa timeout: 30s default (configurable) por request
7. Service valida response status codes e transforma em typed errors: 400→ValidationError, 401/403→AuthError, 404→NotFoundError, 429→RateLimitError, 5xx→ServerError
8. Service normaliza response body: parse JSON, handle empty responses, validate against expected schema
9. Service loga todas as requests (method, path, status, latency) para observability
10. Unit tests com mock HTTP server validam: success cases, retry logic, error handling, rate limiting
11. Classes, métodos e custom errors documentados com TSDoc (descriptions, @param, @returns, @throws)

## Tasks / Subtasks

- [x] Task 1: Criar estrutura base do BitbucketClientService (AC: 1, 2)
  - [x] Criar arquivo `src/services/bitbucket-client.ts` seguindo project structure
  - [x] Definir interface TypeScript `BitbucketClientService` com método `executeOperation(operationId: string, params: unknown): Promise<unknown>`
  - [x] Implementar constructor recebendo dependencies: `AuthManager`, `RateLimiter`, `Logger`, `Config` (dependency injection pattern)
  - [x] Adicionar TSDoc comments: @param, @returns, @example para classe e método principal
  - [x] Definir interface `OperationMetadata` com fields: path, method, parameters, requestBody, responses

- [x] Task 2: Implementar executeOperation com HTTP calls (AC: 2, 3)
  - [x] Buscar operation metadata do `EmbeddingsRepository.getOperation(operationId)`
  - [x] Construir URL completa: `${config.bitbucket_url}${operation.path}` substituindo path parameters (ex: `{issueIdOrKey}`) com valores de params
  - [x] Extrair query parameters, headers, body de params object baseado em operation metadata
  - [x] Obter auth headers do `AuthManager.getAuthHeaders()`
  - [x] Executar HTTP call usando `node-fetch` (native to Node 22+) com method, headers, body
  - [x] Usar `fetch(url, { method, headers, body, signal: AbortSignal.timeout(30000) })` para timeout

- [x] Task 3: Implementar custom error classes (AC: 7)
  - [x] Criar `src/services/errors.ts` com custom error classes:
    - `BitbucketClientError` (base class)
    - `ValidationError extends BitbucketClientError` (400)
    - `AuthError extends BitbucketClientError` (401/403)
    - `NotFoundError extends BitbucketClientError` (404)
    - `RateLimitError extends BitbucketClientError` (429)
    - `ServerError extends BitbucketClientError` (5xx)
  - [x] Cada error class deve ter fields: `statusCode: number`, `message: string`, `operation_id: string`, `response?: unknown`
  - [x] Documentar error classes com TSDoc @throws

- [x] Task 4: Implementar retry logic com exponential backoff (AC: 5)
  - [x] Criar método privado `executeWithRetry<T>(fn: () => Promise<T>, retries: number): Promise<T>`
  - [x] Implementar retry loop: max 3 attempts (total 4 tries including initial)
  - [x] Aplicar delays configurados: `[100ms, 500ms, 2000ms]` após cada tentativa falhada
  - [x] Retry apenas para errors transientes: timeout, 429 (RateLimitError), 5xx (ServerError)
  - [x] NÃO retry para: 400, 401, 403, 404 (errors permanentes)
  - [x] Log cada retry attempt com context: `logger.warn('Retrying request', { attempt, operationId, error })`

- [x] Task 5: Integrar RateLimiter para prevenir sobrecarga (AC: 4)
  - [x] Injetar `RateLimiter` (implementado em `src/core/rate-limiter.ts`) via constructor
  - [x] Chamar `await rateLimiter.acquire()` ANTES de cada HTTP request
  - [x] RateLimiter usa token bucket algorithm com 100 tokens/s (configurable)
  - [x] Se rate limit excedido, aguardar até token disponível (não falhar request)

- [x] Task 6: Normalizar response body (AC: 8)
  - [x] Criar método privado `normalizeResponse(response: Response): Promise<unknown>`
  - [x] Verificar `Content-Type` header: se `application/json` → parse com `response.json()`
  - [x] Handle empty responses: status 204 retorna `null`
  - [x] Handle non-JSON responses: retornar response.text() wrapped em objeto `{ raw: string }`
  - [x] Try/catch para JSON.parse failures com error descritivo

- [x] Task 7: Implementar structured logging (AC: 9)
  - [x] Log cada request START: `logger.info('Bitbucket API request', { operationId, method, path, headers: sanitized })`
  - [x] Sanitize auth headers: substituir `Authorization: Bearer xxx` por `Authorization: Bearer ***`
  - [x] Log request END: `logger.info('Bitbucket API response', { operationId, status, latency, bodySize })`
  - [x] Log errors: `logger.error('Bitbucket API error', { operationId, error, statusCode, responseBody })`
  - [x] Usar correlation ID se disponível (para tracing)

- [x] Task 8: Validar response status codes e mapear para errors (AC: 7)
  - [x] Implementar método `handleErrorResponse(response: Response, operationId: string): never`
  - [x] Mapear status codes:
    - 400 → `throw new ValidationError()`
    - 401/403 → `throw new AuthError()`
    - 404 → `throw new NotFoundError()`
    - 429 → `throw new RateLimitError()`
    - 500-599 → `throw new ServerError()`
  - [x] Incluir response body no error para debugging: `await response.json()` ou `await response.text()`

- [x] Task 9: Implementar unit tests com mock HTTP server (AC: 10)
  - [x] Criar `tests/unit/services/bitbucket-client.test.ts`
  - [x] Usar Vitest + `msw` (Mock Service Worker) ou custom mock fetch
  - [x] Test Case 1: Success case - mock Bitbucket retorna 200 OK com JSON body
  - [x] Test Case 2: Retry logic - mock retorna 500, depois 200 (valida 1 retry)
  - [x] Test Case 3: Permanent error - mock retorna 404 (valida NO retry)
  - [x] Test Case 4: Rate limiting - mock 100 requests, valida throttling
  - [x] Test Case 5: Timeout - mock request demorado >30s (valida AbortSignal)
  - [x] Test Case 6: Auth error - mock retorna 401 (valida AuthError thrown)
  - [x] Test Case 7: Empty response - mock retorna 204 (valida null returned)
  - [x] Mock dependencies: `AuthManager.getAuthHeaders()` retorna mock headers

- [x] Task 10: Code review e refactoring (AC: 11)
  - [x] Verificar TSDoc completo em todas public APIs
  - [x] Run `npm run lint` e fix todos os issues
  - [x] Verificar type safety: no `any` types sem justificativa
  - [x] Verificar error handling: todo async code tem try/catch
  - [x] Verificar test coverage: `npm run test:coverage` →  ≥85% line coverage

## Dev Notes

### Tech Stack
[Source: architecture/tech-stack.md#Technology Stack Table]

- **Runtime:** Node.js 22+ LTS (native fetch support)
- **Language:** TypeScript 5.x (strict mode)
- **HTTP Client:** node-fetch 3.x (native to Node 22+, promise-based, fetch API standard)
- **Logging:** pino 8.x (high performance JSON logs, log levels, redaction support)
- **Testing:** Vitest (fast, Jest-compatible API, native ESM)

**Rationale for node-fetch:**
- Native to Node 22+: no external dependencies
- Fetch API standard: familiar API para devs
- Promise-based: async/await support
- Trade-off: axios tem mais features (interceptors, request cancellation), mas fetch é suficiente e mais leve

### Project Structure
[Source: architecture/unified-project-structure.md]

```plaintext
src/
├── services/
│   ├── bitbucket-client.ts          # THIS FILE - BitbucketClientService
│   ├── semantic-search.ts      # (existing)
│   └── errors.ts               # Custom error classes (NEW)
├── core/
│   ├── rate-limiter.ts         # Token bucket rate limiter (dependency)
│   ├── logger.ts               # Structured logging (dependency)
│   └── config-manager.ts       # Config (dependency)
├── auth/
│   └── auth-manager.ts         # AuthManager (dependency)
└── data/
    └── embeddings-repository.ts # EmbeddingsRepository (dependency)
```

**Layered Architecture:**
- Services Layer (business logic) → Core Layer (utilities) → Data Layer
- Dependency flow sempre para baixo (services NÃO dependem de tools, apenas de core/data)

### Coding Standards
[Source: architecture/coding-standards.md]

**Critical Rules:**
- **Type Safety:** TypeScript strict mode, no `any` types sem justificativa
- **Error Handling:** Sempre usar try/catch em async functions, nunca swallow errors
- **Async/Await:** Sempre usar async/await sobre raw Promises
- **No Console.log:** Usar Logger (pino) para todos os logs
- **Input Validation:** Validar todos os inputs externos com Zod schemas
- **Immutability:** Prefer const sobre let, não mutar arrays/objects
- **Dependency Injection:** Classes recebem dependencies via constructor
- **Documentation:** TSDoc comments para public APIs (explain "why" não "what")

**Naming Conventions:**
- Classes: PascalCase (`BitbucketClientService`)
- Functions: camelCase (`executeOperation()`)
- Constants: UPPER_SNAKE_CASE (`MAX_RETRIES`, `DEFAULT_TIMEOUT`)
- Files: kebab-case (`bitbucket-client.ts`, `errors.ts`)

### External API Integration
[Source: architecture/external-apis.md#Bitbucket Data Center REST API]

**Bitbucket DC REST API:**
- **Base URL:** `https://{customer-bitbucket-domain}/rest/api/latest/` (configurable via Config, also supports `/rest/api/1.0/`)
- **Authentication:** Multiple methods (OAuth 2.0, PAT, OAuth 1.0a, Basic HTTP) - AuthManager seleciona strategy
- **Rate Limits:** Customer-controlled (default nenhum limit), MCP implementa client-side 100 req/s para safety
- **Timeout:** 30s default (configurable)
- **Error Handling:** Normalize Bitbucket error codes para MCP errors:
  - 400 → ValidationError
  - 401/403 → AuthError
  - 404 → NotFoundError
  - 429 → RateLimitError
  - 500/503 → ServerError
- **Retries:** 3x exponential backoff (100ms, 500ms, 2s) para 429/5xx
- **Circuit Breaker:** (Epic 3) - não implementar nesta story

**Key Endpoints Examples:**
- `GET /rest/api/latest/projects` - List projects
- `GET /rest/api/latest/projects/{projectKey}/repos` - Get repositories
- `POST /rest/api/latest/projects/{projectKey}/repos` - Create repository
- `GET /rest/api/latest/profile/recent/repos` - Auth test

### Backend Architecture Patterns
[Source: architecture/backend-architecture.md]

**Dependency Injection Pattern:**
```typescript
// src/services/bitbucket-client.ts
export class BitbucketClientService {
  constructor(
    private authManager: AuthManager,
    private rateLimiter: RateLimiter,
    private logger: Logger,
    private config: Config,
    private embeddingsRepository: EmbeddingsRepository
  ) {}
}
```

**Error Handling Pattern:**
- Custom error classes extending base `BitbucketClientError`
- Include context: `statusCode`, `operationId`, `response`
- Typed errors para control flow (catch ValidationError vs AuthError)

**Logging Pattern:**
- Structured logging com pino: `logger.info(message, context)`
- Redaction para credentials: sanitize `Authorization` headers
- Include correlation ID para distributed tracing

### Testing Standards
[Source: architecture/testing-strategy.md]

**Test Organization:**
```
tests/unit/services/
└── bitbucket-client.test.ts  # Unit tests para BitbucketClientService
```

**Test Pattern (Vitest):**
```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { BitbucketClientService } from '../../../src/services/bitbucket-client.js';

describe('BitbucketClientService', () => {
  let service: BitbucketClientService;
  let mockAuthManager: vi.Mocked<AuthManager>;
  
  beforeEach(() => {
    mockAuthManager = {
      getAuthHeaders: vi.fn().mockResolvedValue(new Headers({'Authorization': 'Bearer mock-token'}))
    } as any;
    
    service = new BitbucketClientService(mockAuthManager, ...);
  });
  
  it('should execute operation successfully', async () => {
    // Mock HTTP response
    global.fetch = vi.fn().mockResolvedValue({
      ok: true,
      status: 200,
      json: async () => ({ id: '10001', key: 'PROJ-1' })
    });
    
    const result = await service.executeOperation('create_issue', { fields: {...} });
    
    expect(result).toEqual({ id: '10001', key: 'PROJ-1' });
  });
});
```

**Coverage Targets:**
- Unit tests: ≥85% line coverage
- Test success cases + error cases + edge cases
- Mock external dependencies (AuthManager, fetch, RateLimiter)

### Rate Limiting Implementation
[Source: architecture/backend-architecture.md (implied from requirements)]

**Token Bucket Algorithm:**
- Capacity: 100 tokens (configurable)
- Refill rate: 100 tokens/second
- Cada request consome 1 token
- Se bucket vazio, aguardar até token disponível

**Implementation (já existe em src/core/rate-limiter.ts):**
```typescript
await rateLimiter.acquire(); // Blocks until token available
// Execute HTTP request
```

### Retry Logic Implementation

**Exponential Backoff:**
```typescript
const RETRY_DELAYS = [100, 500, 2000]; // ms

async function executeWithRetry<T>(fn: () => Promise<T>, maxRetries: number = 3): Promise<T> {
  let lastError: Error;
  
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;
      
      // Não retry para errors permanentes
      if (error instanceof ValidationError || 
          error instanceof AuthError || 
          error instanceof NotFoundError) {
        throw error;
      }
      
      // Retry para errors transientes
      if (attempt < maxRetries && 
          (error instanceof RateLimitError || error instanceof ServerError)) {
        const delay = RETRY_DELAYS[attempt];
        logger.warn('Retrying request', { attempt: attempt + 1, delay, error });
        await sleep(delay);
        continue;
      }
      
      throw lastError;
    }
  }
  
  throw lastError!;
}
```

### Operation Metadata Structure

**Operation object (from EmbeddingsRepository):**
```typescript
interface Operation {
  operation_id: string;        // ex: "create_repository"
  path: string;                // ex: "/rest/api/latest/projects/{projectKey}/repos"
  method: string;              // ex: "POST"
  summary: string;
  description: string;
  tags: string[];              // JSON parsed
  parameters: Parameter[];     // JSON parsed (path, query, header params)
  requestBody?: RequestBody;   // JSON parsed (schema, examples)
  responses: Record<string, Response>; // JSON parsed (status → response)
}
```

### HTTP Request Construction

**Path Parameters:**
- Substituir `{projectKey}` no path com valor de params
- Exemplo: `/rest/api/latest/projects/{projectKey}` + `params.projectKey = 'PROJ'` → `/rest/api/latest/projects/PROJ`

**Query Parameters:**
- Extrair parameters com `in: 'query'` do operation metadata
- Construir URLSearchParams: `?fields=summary,status&expand=changelog`

**Headers:**
- Merge auth headers (do AuthManager) + custom headers (do params)
- Always include: `Content-Type: application/json` para POST/PUT

**Body:**
- Se method POST/PUT/PATCH, serialize params.fields (ou params.body) para JSON string

### Error Response Handling

**Parse Bitbucket error responses:**
```typescript
// Bitbucket retorna errors neste formato:
{
  "errorMessages": ["Issue does not exist or you do not have permission"],
  "errors": {
    "issueIdOrKey": "Issue key 'INVALID' does not exist"
  }
}
```

Incluir error messages no custom error para debugging.

### No Magic Numbers

Usar constants nomeadas:
```typescript
const MAX_RETRIES = 3;
const DEFAULT_TIMEOUT_MS = 30000; // 30 seconds
const RETRY_DELAYS_MS = [100, 500, 2000];
const RATE_LIMIT_REQUESTS_PER_SECOND = 100;
```

## Testing

### Test Location
[Source: architecture/testing-strategy.md#Backend Tests]

```
tests/unit/services/
└── bitbucket-client.test.ts
```

### Testing Framework
- **Vitest:** Fast, Vite-powered, Jest-compatible API

### Test Standards

**Test Coverage Requirements:**
- Minimum 85% line coverage
- Test success cases, error cases, edge cases
- Mock all external dependencies

**Test Cases Required (from AC 10):**
1. Success case - 200 OK with JSON body
2. Retry logic - 500 → 200 (validates retry)
3. Permanent error - 404 (validates NO retry)
4. Rate limiting - 100+ requests (validates throttling)
5. Timeout - request >30s (validates AbortSignal)
6. Auth error - 401 (validates AuthError)
7. Empty response - 204 (validates null)

**Mock Strategy:**
- Mock `global.fetch` usando `vi.fn()`
- Mock `AuthManager.getAuthHeaders()` para retornar mock headers
- Mock `RateLimiter.acquire()` para não throttle tests
- Mock `EmbeddingsRepository.getOperation()` para retornar mock operation metadata

### Test Example Pattern
```typescript
it('should retry on 500 error and succeed', async () => {
  let callCount = 0;
  
  global.fetch = vi.fn().mockImplementation(() => {
    callCount++;
    if (callCount === 1) {
      return Promise.resolve({ ok: false, status: 500, statusText: 'Server Error' });
    }
    return Promise.resolve({ ok: true, status: 200, json: async () => ({ success: true }) });
  });
  
  const result = await service.executeOperation('test_op', {});
  
  expect(callCount).toBe(2); // First call failed, second succeeded
  expect(result).toEqual({ success: true });
});
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-16 | 1.0 | Initial story draft created | Bob (Scrum Master) |
| 2025-10-16 | 1.1 | Added Prerequisites section for clarity on dependencies | Bob (Scrum Master) |
| 2025-10-16 | 1.2 | Corrected retry delay values in Task 4 (100ms, 500ms, 2000ms) | Bob (Scrum Master) |
| 2025-10-16 | 2.0 | Story approved and ready for development | Bob (Scrum Master) |
| 2025-10-16 | 2.1 | PO validation passed - story approved and ready for dev | Sarah (PO) |
| 2025-10-16 | 2.2 | Story validated - date corrections applied | AI Dev Agent |
| 2025-10-18 | 3.0 | Implementation completed - all tasks done, 29 tests passing | James (Dev Agent) |

## Dev Agent Record

### Agent Model Used

Claude 3.5 Sonnet (claude-sonnet-4-20250514)

### Debug Log References

No critical issues encountered during implementation.

### Completion Notes List

- ✅ Created stub implementations for AuthManager and RateLimiter dependencies
- ✅ Implemented BitbucketClientService with all required functionality:
  - Rate limiting using token bucket algorithm
  - Retry logic with exponential backoff (100ms, 500ms, 2000ms delays)
  - Comprehensive error handling with typed error classes
  - Request timeout handling (30s default)
  - Response normalization (JSON parsing, empty responses, non-JSON)
  - Structured logging with sanitized headers
- ✅ Created custom error class hierarchy (ValidationError, AuthError, NotFoundError, RateLimitError, ServerError, TimeoutError)
- ✅ Implemented comprehensive unit tests - 29 test cases covering all scenarios
- ✅ All tests passing (100% success rate)
- ✅ No lint errors
- ✅ TypeScript compilation successful (no type errors)
- ✅ TSDoc documentation complete for all public APIs

**Implementation Notes:**
- Used existing `JsonOperationsRepository` instead of creating new EmbeddingsRepository
- Pino logger signature requires context object first, then message string
- Path parameters are URL-encoded for safety
- Headers are sanitized in logs (Authorization tokens redacted)

### File List

**Source Files:**
- `src/services/bitbucket-client.ts` - Main BitbucketClientService implementation (627 lines)
- `src/services/errors.ts` - Custom error class hierarchy (218 lines)
- `src/auth/auth-manager.ts` - Stub AuthManager implementation (32 lines)
- `src/core/rate-limiter.ts` - Token bucket RateLimiter implementation (96 lines)

**Test Files:**
- `tests/unit/services/bitbucket-client.test.ts` - Comprehensive test suite (686 lines, 29 tests)

**Dependencies Used:**
- `src/core/logger.ts` (existing)
- `src/core/config-manager.ts` (existing)
- `src/data/operations-repository.ts` (existing)
- `src/tools/get-id-tool.ts` (existing - for Operation interface)

## QA Results

_Pending implementation and QA review_

