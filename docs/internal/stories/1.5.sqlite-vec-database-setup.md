# Story 1.5: sqlite-vec Database Setup

## Status

Ready for Review

## Story

**As a** developer,  
**I want** embeddings armazenados em sqlite-vec database com índice vetorial otimizado,  
**so that** posso fazer semantic search queries com latency <100ms.

## Acceptance Criteria

1. Script `scripts/populate-db.ts` cria database `data/embeddings.db` usando better-sqlite3 + sqlite-vec extension
2. Database schema criado com tables: `operations` (id, operation_id, summary, description), `embeddings` (operation_id, vector BLOB)
3. sqlite-vec virtual table criado para similarity search: `CREATE VIRTUAL TABLE vec_index USING vec0(...)`
4. Script popula tables lendo `data/operations.json` e `data/embeddings.json`
5. Vectors são armazenados em formato binário otimizado (float32 array)
6. Database tem índice criado em operation_id para fast lookups
7. Script valida database integrity após population (count matches, no nulls)
8. Database file é otimizado com `VACUUM` para reduce size
9. Unit tests com in-memory database validam: insert operations, vector search queries retornam results

## Tasks / Subtasks

- [x] Task 1: Criar estrutura base do script e schema SQL (AC: 1, 2, 3)
  - [x] Criar arquivo `scripts/populate-db.ts` com imports: better-sqlite3, fs/promises
  - [x] Definir interfaces TypeScript: `OperationRow`, `EmbeddingRow`, `DatabaseStats`
  - [x] Criar SQL schema string com tables: `operations`, `embeddings`, `schema_metadata`
  - [x] Implementar função `createDatabase(dbPath: string): Database` que:
    - Deleta DB existente se houver (fresh rebuild) - Log warning antes: `console.warn('[populate-db] Deleting existing database:', dbPath)`
    - Cria novo database file
    - Carrega sqlite-vec extension: `db.loadExtension('vec0')` (default approach - loads from node_modules automatically)
    - Verifica extension foi carregada: `db.prepare("SELECT vec_version()").get()` e log version
    - Executa DDL statements (CREATE TABLE operations, CREATE VIRTUAL TABLE embeddings USING vec0)
    - Insere metadata: schema_version='1.0.0', built_at=timestamp, openapi_version='11.0.1'
  - [x] **Implementation Pattern:**
    ```typescript
    function createDatabase(dbPath: string): Database {
      // Delete existing DB for fresh rebuild
      if (fs.existsSync(dbPath)) {
        fs.unlinkSync(dbPath);
      }
      
      // Create new database
      const db = new Database(dbPath);
      
      // Load sqlite-vec extension
      db.loadExtension('vec0');
      
      // Execute DDL (use db.exec() for multiple statements)
      db.exec(SCHEMA_SQL);
      
      // Insert metadata
      db.prepare("INSERT INTO schema_metadata (key, value) VALUES (?, ?)").run('version', '1.0.0');
      db.prepare("INSERT INTO schema_metadata (key, value) VALUES (?, ?)").run('built_at', new Date().toISOString());
      db.prepare("INSERT INTO schema_metadata (key, value) VALUES (?, ?)").run('openapi_version', '11.0.1');
      
      return db;
    }
    ```
  - [x] Schema SQL exato:
    ```sql
    CREATE TABLE operations (
        operation_id TEXT PRIMARY KEY,
        path TEXT NOT NULL,
        method TEXT NOT NULL,
        summary TEXT NOT NULL,
        description TEXT,
        tags TEXT, -- JSON array
        parameters TEXT, -- JSON array
        request_body TEXT, -- JSON schema
        responses TEXT, -- JSON responses
        deprecated INTEGER DEFAULT 0,
        created_at TEXT DEFAULT CURRENT_TIMESTAMP
    );
    
    CREATE VIRTUAL TABLE embeddings USING vec0(
        operation_id TEXT PRIMARY KEY,
        vector FLOAT[768]
    );
    
    CREATE TABLE schema_metadata (
        key TEXT PRIMARY KEY,
        value TEXT NOT NULL,
        updated_at TEXT DEFAULT CURRENT_TIMESTAMP
    );
    
    CREATE INDEX idx_operations_method ON operations(method);
    CREATE INDEX idx_operations_deprecated ON operations(deprecated) WHERE deprecated = 0;
    ```
  - [x] Error handling: throw se sqlite-vec extension não carrega, validate file paths

- [x] Task 2: Implementar população de operations table (AC: 4, 6)
  - [x] Implementar função `loadOperations(path: string): Promise<Operation[]>` que lê `data/operations.json`
  - [x] Implementar função `insertOperations(db: Database, operations: Operation[]): number` que:
    - Usa transaction para batch insert (performance)
    - Prepared statement: `INSERT INTO operations (operation_id, path, method, summary, description, tags, parameters, request_body, responses, deprecated) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`
    - Serializa tags/parameters/request_body/responses como JSON strings
    - Retorna count de rows inseridas
  - [x] Progress indicator: `console.log` a cada 100 operations usando format: `[populate-db] Inserting operations: ${count}/${total} (${Math.round(count/total*100)}%)...`
  - [x] Validação: se operation_id duplicado, log warning e skip (não crash)

- [x] Task 3: Implementar população de embeddings table (AC: 4, 5)
  - [x] Implementar função `loadEmbeddings(path: string): Promise<EmbeddingData[]>` que lê `data/embeddings.json`
  - [x] Interface: `EmbeddingData { operation_id: string; vector: number[]; }`
  - [x] Implementar função `insertEmbeddings(db: Database, embeddings: EmbeddingData[]): number` que:
    - Usa transaction para batch insert
    - Converte `number[]` para `Float32Array` e depois `Buffer`: `Buffer.from(new Float32Array(vector).buffer)`
    - Prepared statement: `INSERT INTO embeddings (operation_id, vector) VALUES (?, vec_f32(?))`
    - Retorna count de rows inseridas
  - [x] Progress indicator: `console.log` a cada 100 embeddings usando format: `[populate-db] Inserting embeddings: ${count}/${total} (${Math.round(count/total*100)}%)...`
  - [x] Error handling: se operation_id não existe em operations table, log error e skip embedding

- [x] Task 4: Implementar validação de integridade e otimização (AC: 7, 8)
  - [x] Implementar função `validateDatabase(db: Database): DatabaseStats` que:
    - Query 1: `SELECT COUNT(*) as count FROM operations` → verifica count matches input
    - Query 2: `SELECT COUNT(*) as count FROM embeddings` → verifica count matches input
    - Query 3: `SELECT COUNT(*) FROM operations WHERE operation_id IS NULL OR summary IS NULL` → verifica no nulls
    - Query 4: `SELECT COUNT(*) FROM operations o LEFT JOIN embeddings e ON o.operation_id = e.operation_id WHERE e.operation_id IS NULL` → verifica orphaned operations (sem embedding)
    - Retorna stats: `{ operationsCount, embeddingsCount, nullCount, orphanedCount }`
  - [x] Se validation fails (nullCount > 0 ou orphanedCount > 0), throw error com detalhes
  - [x] Implementar função `optimizeDatabase(db: Database)` que:
    - Executa `ANALYZE` para atualizar query planner statistics
    - Executa `VACUUM` para compactar database e liberar espaço
    - Log antes/depois file size: `Database optimized: ${beforeSize}MB → ${afterSize}MB`
  - [x] Medir database file size: `fs.stat(dbPath).size / (1024 * 1024)` MB

- [x] Task 5: Implementar main function e CLI (AC: 1)
  - [x] Implementar função `main()` async que:
    - **Prerequisite check**: Verify `data/operations.json` and `data/embeddings.json` exist (generated by Stories 1.2-1.4), throw error with helpful message if missing
    - Load operations de `data/operations.json`
    - Load embeddings de `data/embeddings.json`
    - Create database em `data/embeddings.db`
    - Insert operations (com progress)
    - Insert embeddings (com progress)
    - Validate database integrity
    - Optimize database (VACUUM)
    - Log final stats: operations count, embeddings count, database size, duration
  - [x] Error handling: catch all errors, log com context, exit(1) on failure
  - [x] Script executável via: `npm run populate-db` ou `tsx scripts/populate-db.ts`

- [x] Task 6: Adicionar testes unitários (AC: 9)
  - [x] Criar arquivo `tests/unit/populate-db.test.ts`
  - [x] Setup: criar in-memory database para cada test: `new Database(':memory:')`
  - [x] Test 1: "should create database schema successfully"
    - Chama `createDatabase(':memory:')`
    - Verifica tables existem: `SELECT name FROM sqlite_master WHERE type='table'`
    - Assert: operations, embeddings, schema_metadata tables presentes
  - [x] Test 2: "should insert operations with all fields"
    - Mock operations data (3 operations)
    - Chama `insertOperations(db, mockOperations)`
    - Query: `SELECT * FROM operations`
    - Assert: 3 rows, fields corretos, JSON parsed corretamente
  - [x] Test 3: "should insert embeddings as float32 binary"
    - Mock embeddings data (vector com 768 floats)
    - Chama `insertEmbeddings(db, mockEmbeddings)`
    - Query: `SELECT operation_id, length(vector) FROM embeddings`
    - Assert: vector tem 768 * 4 bytes = 3072 bytes
  - [x] Test 4: "should perform cosine similarity search"
    - Insert 5 operations + embeddings
    - Query embedding com vector conhecido
    - SQL: `SELECT operation_id, vec_distance_cosine(vector, ?) as distance FROM embeddings ORDER BY distance LIMIT 3`
    - Assert: retorna 3 results ordenados por similarity
  - [x] Test 5: "should validate database integrity"
    - Insert operations (5 operations)
    - Insert embeddings (4 embeddings - 1 orphaned)
    - Chama `validateDatabase(db)`
    - Assert: stats.orphanedCount === 1
  - [x] All tests usam Vitest framework, structure: `describe('populate-db', () => { ... })`

## Dev Notes

### Tech Stack
[Source: architecture/tech-stack.md]
- **SQLite Driver**: better-sqlite3 (latest) - Synchronous API, high performance, native bindings
- **Vector Extension**: sqlite-vec (latest) - Embedded zero-config, cosine similarity search <100ms
- **Runtime**: Node.js 22+ LTS
- **Language**: TypeScript 5.x (strict mode)
- **Testing**: Vitest (latest)

**sqlite-vec Extension Setup:**
```typescript
// Carregando a extension no better-sqlite3
import Database from 'better-sqlite3';

const db = new Database('data/embeddings.db');

// Opção 1: Se sqlite-vec está instalado como npm package
db.loadExtension('vec0'); // Carrega do node_modules automaticamente

// Opção 2: Se usando .so/.dll binário específico
// const extensionPath = path.join(__dirname, '../node_modules/sqlite-vec/vec0.so');
// db.loadExtension(extensionPath);

// Verificar se extension foi carregada:
const result = db.prepare("SELECT vec_version()").get();
console.log('sqlite-vec version:', result);
```

**Instalação da Extension:**
```bash
# sqlite-vec geralmente é incluído automaticamente pelo better-sqlite3
# Mas se necessário instalar separadamente:
npm install sqlite-vec
```

**Troubleshooting Common Issues:**
- **Error "not authorized"**: better-sqlite3 precisa ser compiled com suporte a extensions. Use `npm rebuild better-sqlite3`
- **Extension not found**: Verifique se `sqlite-vec` está em `node_modules/` ou forneça path absoluto
- **Platform-specific**: Extension binaries são diferentes para Linux/macOS/Windows (.so/.dylib/.dll)

### Database Schema
[Source: architecture/database-schema.md]

**Operations Table:**
```sql
CREATE TABLE operations (
    operation_id TEXT PRIMARY KEY,
    path TEXT NOT NULL,
    method TEXT NOT NULL,
    summary TEXT NOT NULL,
    description TEXT,
    tags TEXT, -- JSON array
    parameters TEXT, -- JSON array
    request_body TEXT, -- JSON
    responses TEXT, -- JSON
    deprecated INTEGER DEFAULT 0,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP
);
```

**Embeddings Virtual Table (sqlite-vec):**
```sql
CREATE VIRTUAL TABLE embeddings USING vec0(
    operation_id TEXT PRIMARY KEY,
    vector FLOAT[768] -- Xenova/all-mpnet-base-v2 dimensions
);
```

**Schema Metadata Table:**
```sql
CREATE TABLE schema_metadata (
    key TEXT PRIMARY KEY,
    value TEXT NOT NULL,
    updated_at TEXT DEFAULT CURRENT_TIMESTAMP
);
```

**Indexes:**
```sql
CREATE INDEX idx_operations_method ON operations(method);
CREATE INDEX idx_operations_deprecated ON operations(deprecated) WHERE deprecated = 0;
```

**Cosine Similarity Query Pattern:**
```sql
SELECT 
  e.operation_id,
  o.summary,
  o.description,
  vec_distance_cosine(e.vector, ?) as distance
FROM embeddings e
JOIN operations o ON e.operation_id = o.operation_id
WHERE o.deprecated = 0
ORDER BY distance ASC  -- ASC porque distance (menor = mais similar)
LIMIT ?;
```

### Data Models
[Source: architecture/data-models.md]

**Operation Interface:**
```typescript
interface Operation {
  operation_id: string;
  path: string;
  method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
  summary: string;
  description: string;
  tags: string[];
  parameters: Parameter[];
  requestBody: RequestBody | null;
  responses: Record<string, Response>;
  deprecated: boolean;
}
```

**Embedding Interface:**
```typescript
interface Embedding {
  operation_id: string;
  vector: Float32Array; // 768 floats
  model: string;
  created_at: Date;
}
```

### File Locations
[Source: architecture/unified-project-structure.md]
- **Script**: `scripts/populate-db.ts`
- **Database Output**: `data/embeddings.db` (gitignored)
- **Input Data**: `data/operations.json`, `data/embeddings.json`
- **Tests**: `tests/unit/populate-db.test.ts`

### Previous Story Insights
[Source: Story 1.4]
- `data/embeddings.json` format: array de `{ operation_id: string, vector: number[] }`
- Vectors têm 768 dimensions (Xenova/all-mpnet-base-v2)
- `data/operations.json` já foi criado pela Story 1.2

**Expected Input Format Examples:**

`data/operations.json`:
```json
[
  {
    "operation_id": "create_issue",
    "path": "/rest/api/3/issue",
    "method": "POST",
    "summary": "Create issue",
    "description": "Creates an issue or a sub-task from a JSON representation.",
    "tags": ["Issues"],
    "parameters": [...],
    "requestBody": { "content": {...} },
    "responses": { "201": {...} },
    "deprecated": false
  },
  // ... mais ~500 operations
]
```

`data/embeddings.json`:
```json
[
  {
    "operation_id": "create_issue",
    "vector": [0.0234, -0.0456, 0.0123, ..., 0.0789] // 768 floats
  },
  // ... mais ~500 embeddings
]
```

**Critical Validation:**
- operations.json e embeddings.json devem ter MESMO count de entries
- Cada embedding.operation_id DEVE existir em operations
- Se count mismatch, script deve log warning mas continuar (graceful degradation)

### Performance Targets
[Source: architecture/database-schema.md]
- Database size: ~4MB total (~3MB embeddings + ~1MB metadata)
- Query latency: <100ms para cosine similarity search (target <50ms median)
- Population time: <30 segundos para 500 operations

### Coding Standards
[Source: architecture/coding-standards.md]
- **Type Safety**: TypeScript strict mode, no `any` types
- **Error Handling**: Always use try/catch em async functions, nunca swallow errors
- **Async/Await**: Sempre usar async/await sobre raw Promises
- **No Console.log**: NO! Usar console.log é permitido APENAS em build scripts (não em runtime code)
- **Constants**: Usar UPPER_SNAKE_CASE para constants (ex: `DEFAULT_DB_PATH`, `VECTOR_DIMENSIONS`)
- **File Naming**: kebab-case (ex: `populate-db.ts`)

### Testing

#### Test Organization
[Source: architecture/testing-strategy.md]
- **Unit Tests Location**: `tests/unit/populate-db.test.ts`
- **Framework**: Vitest
- **Test Pattern**: Use in-memory database `:memory:` para cada test
- **Coverage Target**: ≥85% line coverage

#### Test Example Pattern
```typescript
import { describe, it, expect, beforeEach } from 'vitest';
import Database from 'better-sqlite3';

describe('populate-db', () => {
  let db: Database.Database;
  
  beforeEach(() => {
    db = new Database(':memory:');
    // Load sqlite-vec extension
    // Create schema
  });
  
  it('should create database schema successfully', () => {
    // Test implementation
    expect(/* assertion */).toBe(/* expected */);
  });
});
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-15 | 1.0 | Initial story creation for Epic 1.5 | Bob (Scrum Master) |
| 2025-01-15 | 1.1 | Added sqlite-vec extension setup instructions, input format examples, and implementation pattern for createDatabase function | Bob (Scrum Master) |
| 2025-10-16 | 1.2 | Story validation completed - added explicit warning for DB deletion, clarified sqlite-vec extension loading verification, standardized progress logging format across all tasks. Validation score: 9.5/10. Status: APPROVED for implementation. | Sarah (Product Owner) |
| 2025-10-16 | 1.3 | Added prerequisite check in Task 5 to verify input files exist before processing. Final validation: APPROVED. | GitHub Copilot |
| 2025-10-17 | 1.4 | Implemented populate-db pipeline, added unit coverage, and prepared npm script for execution. Status updated to Ready for Review. | James (Dev Agent) |

## Dev Agent Record

_This section will be populated by the development agent during implementation._

### Agent Model Used

GPT-5-Codex (GitHub Copilot)

### Debug Log References

- `npm rebuild better-sqlite3 sqlite-vec`
- `npm run lint`
- `npm test`

### Completion Notes List

- Implemented `scripts/populate-db.ts` with schema creation, batch inserts, validation, optimisation, and CLI entrypoint.
- Added comprehensive unit coverage in `tests/unit/scripts/populate-db.test.ts` validating schema, data loading, cosine queries, and safety checks.
- Registered `populate-db` npm script and exported constants to support testing usage.
- Rebuilt native sqlite modules to align with Node 22 runtime prior to test execution.

### File List

- scripts/populate-db.ts
- tests/unit/scripts/populate-db.test.ts
- package.json

## QA Results

_This section will be populated by the QA Agent after story completion._

