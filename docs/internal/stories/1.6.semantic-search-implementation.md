# Story 1.6: Semantic Search Implementation

## Status

Ready for Review

## Story

**As a** developer,  
**I want** função de semantic search que aceita natural language query e retorna top 5 relevant operations,  
**so that** usuários podem descobrir Bitbucket endpoints sem conhecer nomes técnicos.

## Acceptance Criteria

1. Classe `SemanticSearchService` em `src/services/semantic-search.ts` implementada
2. Método `search(query: string, limit: number = 5): Promise<SearchResult[]>` implementado
3. Query string é convertida para embedding usando Transformers.js local (Xenova/all-mpnet-base-v2)
4. Embedding é usado para cosine similarity search na sqlite-vec database
5. Top N results são retornados com: operationId, summary, description, similarity score (0-1)
6. Results são ordenados por similarity score descending
7. Service tem caching layer para frequent queries (LRU cache, max 1000 entries)
8. Service implementa error handling para: model loading failures, database errors, invalid queries
9. Unit tests com mock database validam search logic
10. Integration tests com real embeddings.db validam: search("update issue assignee") returns relevant operations with score >0.75
11. Classes e métodos públicos documentados com TSDoc (descriptions, @param, @returns, @throws)

## Tasks / Subtasks

- [x] Task 1: Criar estrutura base do SemanticSearchService (AC: 1, 2)
  - [x] Criar arquivo `src/services/semantic-search.ts` com imports necessários
  - [x] Definir interfaces TypeScript: `SearchResult`, `SearchOptions`
  - [x] Implementar classe `SemanticSearchService` com constructor injection (EmbeddingsRepository)
  - [x] Implementar método `search(query: string, limit: number = 5): Promise<SearchResult[]>`
  - [x] Adicionar TSDoc comments na classe e métodos públicos (@param, @returns, @throws)

- [x] Task 2: Implementar query embedding generation usando Transformers.js (AC: 3)
  - [x] Integrar @xenova/transformers library para embeddings locais
  - [x] Criar método privado `generateQueryEmbedding(query: string): Promise<Float32Array>`
  - [x] Usar modelo Xenova/all-mpnet-base-v2 (768 dimensions)
  - [x] Implementar lazy loading do modelo (load on first use)
  - [x] Error handling para model loading failures (throw descriptive errors)
  - [x] Validar query não está vazia antes de gerar embedding

- [x] Task 3: Implementar cosine similarity search via EmbeddingsRepository (AC: 4, 5, 6)
  - [x] Chamar `embeddingsRepository.search(queryEmbedding, limit)` com embedding gerado
  - [x] Processar results do repository (já incluem similarity_score)
  - [x] Ordenar results por similarity_score descending (repo já retorna ordenado)
  - [x] Mapear results para formato `SearchResult[]` com: operation_id, summary, description, similarity_score
  - [x] Validar limit parameter (1-100 range, default 5)

- [x] Task 4: Implementar caching layer para queries frequentes (AC: 7)
  - [x] **Approach**: Use `lru-cache` npm package (preferred) or implement simple Map-based LRU if library not available
  - [x] Criar classe wrapper `QueryCache` em `src/core/cache-manager.ts` para encapsular lógica
  - [x] Cache key: hash SHA256 da query string (normalize case, trim whitespace)
  - [x] Cache value: array de SearchResult (cached embeddings)
  - [x] Max cache size: 1000 entries (configurável via config)
  - [x] TTL (Time To Live): 1 hour (evita stale results se database é atualizado)
  - [x] Cache bypass se query tem `_` prefix (debugging)

- [x] Task 5: Implementar error handling robusto (AC: 8)
  - [x] Try/catch no método `search()` com error categories:
    - `ModelLoadError`: Falha ao carregar Transformers.js model
    - `DatabaseError`: Falha ao query sqlite-vec database
    - `ValidationError`: Query inválida (empty, too long >1000 chars)
  - [x] Logging estruturado com pino para todos os errors (incluir context: query, stacktrace)
  - [x] Rethrow errors com mensagens user-friendly
  - [x] Return empty array [] se query é válida mas nenhum result encontrado (não é error)

- [x] Task 6: Escrever unit tests com mock database (AC: 9)
  - [x] Criar arquivo `tests/unit/services/semantic-search.test.ts`
  - [x] Setup: Mock EmbeddingsRepository com Vitest `vi.fn()`
  - [x] Test case: "should return top 5 operations by similarity score"
    - Mock repository.search() retorna 5 results com scores 0.96-0.75
    - Assert results.length === 5
    - Assert results ordenados por score descending
    - Assert repository.search() foi chamado com Float32Array e limit=5
  - [x] Test case: "should cache query embeddings"
    - Executar search() 2x com mesma query
    - Assert generateQueryEmbedding() foi chamado apenas 1x (cached)
  - [x] Test case: "should handle model loading failures"
    - Mock Transformers.js throw error
    - Assert search() throws ModelLoadError com mensagem descritiva
  - [x] Test case: "should handle empty query validation"
    - Call search('', 5)
    - Assert throws ValidationError
  - [x] Test case: "should respect limit parameter"
    - Call search('test', 10)
    - Assert repository.search() chamado com limit=10

- [x] Task 7: Escrever integration tests com real database (AC: 10)
  - [x] Criar arquivo `tests/integration/semantic-search.test.ts`
  - [x] Setup: Use real embeddings.db (test fixture) ou in-memory database com sample data
  - [x] Test case: "should find relevant operations for 'update issue assignee'"
    - Execute search('update issue assignee', 5)
    - Assert results.length > 0
    - Assert results[0].operation_id matches 'update_issue_assignee' ou similar
    - Assert results[0].similarity_score > 0.75
  - [x] Test case: "should handle database connection errors"
    - Close database connection
    - Assert search() throws DatabaseError
  - [x] Test case: "end-to-end flow with real Transformers.js model"
    - Use real model (not mocked)
    - Execute search('create new issue', 5)
    - Assert results incluem 'create_issue' com high score

## Dev Notes

### Architecture Context

**Service Layer Organization** [Source: architecture/unified-project-structure.md]
- SemanticSearchService belongs in `src/services/` layer
- Service Layer handles business logic, depends on Core and Data layers
- Dependency flow: Tools → Services → Core → Data (dependencies sempre para baixo)

**Tech Stack** [Source: architecture/tech-stack.md]
- **Runtime**: Node.js 22+ LTS
- **Language**: TypeScript 5.x (strict mode)
- **Embeddings**: @xenova/transformers (Xenova/all-mpnet-base-v2, 768 dimensions)
- **Vector DB**: sqlite-vec (cosine similarity search, <100ms queries)
- **Testing**: Vitest (unit & integration tests)
- **Logging**: pino (structured JSON logs)

### Data Models

**SearchResult Interface** [Source: architecture/data-models.md#Embedding]
```typescript
interface SearchResult {
  operation_id: string;
  similarity_score: number; // 0-1 cosine similarity
  summary: string;
  description: string;
  operation: Operation; // Joined data
}
```

**Embedding Model Details** [Source: architecture/data-models.md#Embedding]
- Vector dimensions: **768** (Xenova/all-mpnet-base-v2)
- Model: Xenova/all-mpnet-base-v2 (Transformers.js local)
- Storage: Float32Array (768 floats)
- Similarity: Cosine similarity (0-1 range, 1 = identical)

**Note**: Implementação atual usa Transformers.js local com all-mpnet-base-v2 (**768 dimensions**) para zero-cost, air-gapped operation.

### Database Access

**EmbeddingsRepository Interface** [Source: architecture/backend-architecture.md#Data Access Layer]
```typescript
class EmbeddingsRepository {
  search(queryVector: Float32Array, limit: number = 5): SearchResult[];
  getOperation(operationId: string): Operation | null;
  close(): void;
}
```

**Cosine Similarity Search** [Source: architecture/database-schema.md]
- Repository já implementa cosine similarity search via sqlite-vec
- Results já são retornados ordenados por similarity (ASC distance = DESC similarity)
- similarity_score é calculado como `1 - distance` (distance é 0-2, similarity é 0-1)

### File Locations

**Source Code Structure** [Source: architecture/unified-project-structure.md]
```
src/
├── services/
│   └── semantic-search.ts       # CRIAR: SemanticSearchService implementation
├── core/
│   ├── logger.ts                # USAR: Logger.getInstance()
│   └── cache-manager.ts         # CRIAR: LRU cache implementation
├── data/
│   └── embeddings-repository.ts # USAR: Já existe, injetar via constructor
```

**Test Structure** [Source: architecture/unified-project-structure.md]
```
tests/
├── unit/
│   └── services/
│       └── semantic-search.test.ts  # CRIAR: Unit tests com mocks
└── integration/
    └── semantic-search.test.ts      # CRIAR: Integration tests com real DB
```

### Coding Standards

**Key Standards** [Source: architecture/coding-standards.md]
- **Type Safety**: TypeScript strict mode, no `any` types
- **Error Handling**: Always try/catch em async functions, custom error classes para domain errors
- **Async/Await**: Sempre usar async/await, não usar .then()/.catch() chains
- **No Console.log**: Usar Logger (pino) para todos os logs
- **Input Validation**: Validar query string (não vazio, max length 1000 chars)
- **Immutability**: Prefer const, nunca mutar arrays/objects
- **Dependency Injection**: EmbeddingsRepository via constructor
- **Documentation**: TSDoc comments para public APIs

**Naming Conventions** [Source: architecture/coding-standards.md]
- Classes: PascalCase (`SemanticSearchService`)
- Functions: camelCase (`search()`, `generateQueryEmbedding()`)
- Variables: camelCase (`queryEmbedding`, `searchResults`)
- Constants: UPPER_SNAKE_CASE (`MAX_CACHE_SIZE`, `DEFAULT_LIMIT`)

### Testing Strategy

**Test Organization** [Source: architecture/testing-strategy.md]
- **Unit Tests** (70%): Mock EmbeddingsRepository, test logic isolation
- **Integration Tests** (25%): Real embeddings.db, test end-to-end flow
- **Coverage Target**: ≥85% line coverage

**Test Example Pattern** [Source: architecture/testing-strategy.md#Backend API Test]
```typescript
describe('SemanticSearchService', () => {
  let service: SemanticSearchService;
  let mockRepository: vi.Mocked<EmbeddingsRepository>;
  
  beforeEach(() => {
    mockRepository = {
      search: vi.fn(),
      getOperation: vi.fn(),
    } as any;
    
    service = new SemanticSearchService(mockRepository);
  });
  
  it('should return top 5 operations by similarity', async () => {
    // Mock setup, execute, assertions
  });
});
```

### Performance Considerations

**Target Performance** [Source: architecture/tech-stack.md]
- Query embedding generation: 80-150ms (CPU-only, acceptable)
- Database cosine similarity search: <100ms (target <50ms median)
- Cache hit: <1ms (in-memory lookup)

**Caching Strategy** [Source: Epic 1.6 AC]
- LRU cache with max 1000 entries
- Key: SHA256 hash of normalized query (lowercase, trimmed)
- Value: SearchResult[] array
- Eviction: Least Recently Used when cache full

### Dependencies

**Required Packages** [Source: architecture/tech-stack.md]
- `@xenova/transformers`: Local embeddings generation
- `better-sqlite3`: Database access (já instalado)
- `pino`: Structured logging (já instalado)

**Import Paths** [Source: architecture/coding-standards.md]
```typescript
import { EmbeddingsRepository } from '../data/embeddings-repository.js';
import { Logger } from '../core/logger.js';
import { CacheManager } from '../core/cache-manager.js';
import { pipeline } from '@xenova/transformers';
```

### Error Handling

**Custom Error Classes** [Source: architecture/coding-standards.md]
```typescript
class ModelLoadError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'ModelLoadError';
  }
}

class DatabaseError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'DatabaseError';
  }
}

class ValidationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'ValidationError';
  }
}
```

### Testing

**Test Framework** [Source: architecture/testing-strategy.md]
- Vitest (fast, native ESM support)
- File naming: `*.test.ts`
- Test location: Mirror structure in `tests/` directory

**Unit Tests Requirements** [Source: AC 9]
- Mock EmbeddingsRepository com Vitest `vi.fn()`
- Test all public methods
- Test error handling paths
- Test caching behavior
- Coverage: ≥85% line coverage

**Integration Tests Requirements** [Source: AC 10]
- Use real embeddings.db (test fixture)
- Test with real Transformers.js model
- Validate search("update issue assignee") returns score >0.75
- Test database connection errors

**Test Commands** [Source: architecture/testing-strategy.md]
```bash
npm test                    # Run all tests
npm test semantic-search    # Run specific test file
npm test -- --coverage      # Run with coverage report
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-15 | 1.0 | Initial story draft created | Bob (Scrum Master) |
| 2025-10-16 | 1.1 | Story validated and approved - Implementation readiness: 9.5/10, all quality checks passed | Sarah (Product Owner) |
| 2025-10-16 | 1.2 | Clarified LRU cache implementation approach (use lru-cache npm package), added TTL and key normalization details. Final validation: APPROVED. | GitHub Copilot |

## Dev Agent Record

_This section will be populated by the development agent during implementation._

### Agent Model Used

_To be filled by dev agent_

### Debug Log References

_To be filled by dev agent_

### Completion Notes List

_To be filled by dev agent_

### File List

_To be filled by dev agent_

## QA Results

_This section will be populated by QA Agent after implementation review._

