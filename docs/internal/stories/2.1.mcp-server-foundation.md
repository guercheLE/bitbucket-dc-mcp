# Story 2.1: MCP Server Foundation

## Status

Ready for Review

## Story

**As a** developer,  
**I want** MCP protocol server implementado com stdio transport usando @modelcontextprotocol/sdk,  
**so that** tenho base para expor tools para LLMs via MCP protocol.

## Acceptance Criteria

1. Classe `McpServer` em `src/core/mcp-server.ts` implementada usando @modelcontextprotocol/sdk
2. Server configurado para stdio transport (read from stdin, write to stdout)
3. Server implementa MCP protocol handshake (initialize, initialized messages)
4. Server registra server info: name="bitbucket-dc-mcp-server", version=(from package.json), capabilities
5. Server tem lifecycle management: startup, ready state, graceful shutdown
6. Server implementa error handling global: uncaught exceptions, unhandled rejections logados e não crasham process
7. Server tem structured logging (pino) para: startup events, protocol messages, errors
8. Integration test valida: server starts, responds to initialize request, shuts down gracefully
9. Server compila para executable: `npm run build` → `dist/index.js` executável via `node dist/index.js`
10. Classes, métodos e interfaces documentados com TSDoc (descriptions, @param, @returns, @example)

## Tasks / Subtasks

- [x] Task 1: Instalar e configurar dependências MCP (AC: 1)
  - [x] Adicionar @modelcontextprotocol/sdk ao package.json
  - [x] Verificar compatibility com Node.js 22+ e TypeScript 5.x
  - [x] Instalar pino para structured logging (se ainda não instalado)
  - [x] Verificar tsconfig.json configurado para strict mode e path aliases

- [x] Task 2: Criar classe McpServer base (AC: 1, 2, 3, 4)
  - [x] Criar arquivo `src/core/mcp-server.ts`
  - [x] Importar e inicializar MCP SDK stdio transport
  - [x] Implementar constructor que recebe Config object
  - [x] Implementar método `initialize()` para setup inicial
    - Registrar server info (name, version, capabilities)
    - Configurar stdio transport
    - Setup MCP protocol handshake handlers
  - [x] Implementar método `start()` que inicia listening on stdin/stdout
  - [x] Implementar propriedade `isReady` para indicar ready state

- [x] Task 3: Implementar lifecycle management (AC: 5)
  - [x] Implementar método `start()` com sequência:
    - Load config
    - Initialize transport
    - Register protocol handlers
    - Emit 'ready' event
  - [x] Implementar método `shutdown()` graceful:
    - Flush pending messages
    - Close transport
    - Cleanup resources (DB connections, cache, etc.)
    - Exit process com status 0
  - [x] Adicionar signal handlers (SIGTERM, SIGINT) no index.ts
  - [x] Implementar timeout para shutdown (30s max, force exit se timeout)

- [x] Task 4: Implementar global error handling (AC: 6, 7)
  - [x] Setup global exception handlers em index.ts:
    - process.on('uncaughtException')
    - process.on('unhandledRejection')
  - [x] Implementar logging de errors com context:
    - Error message, stack trace
    - Correlation ID (se disponível)
    - Timestamp, severity level
  - [x] Prevent process crash: log error mas continue running (graceful degradation)
  - [x] Implementar método `handleError(error, context)` no McpServer

- [x] Task 5: Setup structured logging com pino (AC: 7)
  - [x] Criar singleton Logger em `src/core/logger.ts`
  - [x] Configurar pino com:
    - JSON output format
    - Log levels (debug, info, warn, error)
    - Redaction para credentials (access_token, password)
    - Pretty print em dev mode (enable via env var)
  - [x] Adicionar log statements em McpServer:
    - Startup events ('Server starting...', 'Server ready')
    - Protocol messages ('Received initialize request', 'Handshake complete')
    - Errors ('Error handling request', 'Shutdown initiated')
  - [x] Implementar correlation IDs para trace requests

- [x] Task 6: Criar entry point executável (AC: 9)
  - [x] Criar `src/index.ts` como entry point:
    - Import McpServer
    - Load config via ConfigManager
    - Create server instance
    - Call server.start()
    - Setup signal handlers
  - [x] Configurar tsconfig.json para output em `dist/`
  - [x] Adicionar script em package.json: `"build": "tsc"`
  - [x] Adicionar script em package.json: `"start": "node dist/index.js"`
  - [x] Testar compilação: `npm run build` deve gerar `dist/index.js`
  - [x] Testar execução: `node dist/index.js` deve iniciar server

- [x] Task 7: Documentar código com TSDoc (AC: 10)
  - [x] Adicionar TSDoc comments para:
    - Classe McpServer (description, @example)
    - Método initialize() (@returns, @throws)
    - Método start() (@returns, @throws)
    - Método shutdown() (@returns)
    - Interface Config (cada propriedade)
  - [x] Adicionar examples em TSDoc:
    - Como instanciar McpServer
    - Como handle lifecycle events
  - [x] Garantir TSDoc validation passa em CI (se configurado)

- [x] Task 8: Implementar integration test (AC: 8)
  - [x] Criar `tests/integration/mcp-server.test.ts`
  - [x] Setup test fixtures:
    - Mock config object
    - Helper para spawn server process
    - Helper para send/receive MCP mensagens via stdio
  - [x] Test Case 1: Server starts successfully
    - Spawn server process
    - Assert process não crasha
    - Assert stdout contém startup log
  - [x] Test Case 2: Server responds to initialize request
    - Send MCP initialize message via stdin
    - Wait for initialized response on stdout
    - Assert response contains server info (name, version)
  - [x] Test Case 3: Server shuts down gracefully
    - Send SIGTERM signal
    - Assert server closes connections
    - Assert process exits com status 0 dentro de 5s
  - [x] Test Case 4: Server handles invalid messages
    - Send malformed JSON
    - Assert error response sem crash
  - [x] Usar Vitest para test runner

- [x] Task 9: Unit tests para error handling (AC: 6)
  - [x] Criar `tests/unit/mcp-server.test.ts`
  - [x] Mock dependencies (Logger, Config)
  - [x] Test Case: Uncaught exception handling
    - Trigger exception em handler
    - Assert error é logged
    - Assert server não crasha
  - [x] Test Case: Unhandled rejection handling
    - Trigger rejected promise
    - Assert error é logged
    - Assert server continua running
  - [x] Test Case: Graceful shutdown timeout
    - Mock slow shutdown
    - Assert force exit após timeout

## Dev Notes

### Previous Story Insights

**From Story 1.8 (Search CLI):**
- História anterior implementou CLI standalone para semantic search
- CLI tool usa SemanticSearchService.search() do Epic 1
- File location pattern: `src/cli/*.ts` para CLI tools
- Benchmark suite em `tests/benchmarks/search-relevance.test.ts` valida search quality
- **Lição importante:** Dev Notes completas com source references facilitam implementação

**Key Learnings Relevant to This Story:**
- Já temos SemanticSearchService implementado e testado (Epic 1)
- Database embeddings.db já está populado e funcional
- Testing strategy já estabelecido (Vitest, unit/integration/e2e)
- Project structure já definido (src/, tests/, scripts/)

### Technical Stack

[Source: architecture/tech-stack.md]

**Runtime & Language:**
- Node.js 22+ LTS (native fetch, broad compatibility)
- TypeScript 5.x (strict mode, path aliases)
- npm 9+ (dependency management)

**MCP Implementation:**
- @modelcontextprotocol/sdk (Official Anthropic SDK)
- stdio transport (read stdin, write stdout)
- Type-safe MCP protocol

**Logging:**
- pino 8.x (High performance JSON logs)
- Log levels: debug, info, warn, error
- Redaction support para sanitize credentials

**Testing:**
- Vitest (fast, Vite-powered, Jest-compatible)
- better-sqlite3 para in-memory test DB
- Child process spawning para integration tests

**Build:**
- tsc (TypeScript compiler, incremental builds)
- No bundler needed (Node.js runs compiled JS directly)

### Project Structure

[Source: architecture/unified-project-structure.md]

```plaintext
src/
├── core/                     # Core Layer (Utilities)
│   ├── mcp-server.ts         # ⭐ CREATE THIS: MCP protocol handler
│   ├── config-manager.ts     # Config loader & validator (if exists)
│   ├── logger.ts             # ⭐ CREATE THIS: Structured logging (pino)
│   └── (outros core utilities...)
├── services/                 # Service Layer (já existe do Epic 1)
│   └── semantic-search.ts    # Semantic search engine (Epic 1)
├── data/                     # Data Access Layer (já existe)
│   └── embeddings-repository.ts # sqlite-vec queries (Epic 1)
└── index.ts                  # ⭐ CREATE THIS: Entry point

tests/
├── unit/
│   └── core/
│       └── mcp-server.test.ts  # ⭐ Unit tests para McpServer
└── integration/
    └── mcp-server.test.ts      # ⭐ Integration test
```

**Layered Organization:**
- Tools → Services → Core → Data (dependency flow sempre para baixo)
- Core layer: Foundation utilities (MCP server, logger, config)
- No circular dependencies

### MCP Server Architecture

[Source: architecture/backend-architecture.md#Service Architecture]

**Server Entry Point Template:**
```typescript
// src/index.ts
import { MCPServer } from './core/mcp-server.js';
import { ConfigManager } from './core/config-manager.js';
import { Logger } from './core/logger.js';

async function main() {
  const logger = Logger.getInstance();
  
  try {
    // Load config from file/env vars
    const config = await ConfigManager.load();
    
    // Initialize MCP server
    const server = new MCPServer(config);
    
    // Register tools (será feito em stories futuras)
    await server.registerTools();
    
    // Start listening on stdio
    await server.start();
    
    logger.info('MCP Server started successfully', {
      version: process.env.npm_package_version,
      bitbucket_url: config.bitbucket_url,
    });
    
    // Graceful shutdown handlers
    process.on('SIGTERM', () => server.shutdown());
    process.on('SIGINT', () => server.shutdown());
    
  } catch (error) {
    logger.error('Failed to start MCP server', { error });
    process.exit(1);
  }
}

main();
```

**Process Organization:**
- Single-threaded Node.js process
- Async/await para I/O operations
- No worker threads needed (I/O-bound workload)

### MCP Protocol Handshake

[Source: architecture/api-specification.md]

**MCP Protocol Flow:**
1. Client sends `initialize` request via stdin
2. Server responds com server info (name, version, capabilities)
3. Client sends `initialized` notification
4. Protocol ready - client pode chamar tools

**Server Info Structure:**
```json
{
  "name": "bitbucket-dc-mcp-server",
  "version": "1.0.0",  // from package.json
  "capabilities": {
    "tools": {
      "search_ids": true,
      "get_id": true,
      "call_id": true
    }
  }
}
```

**stdio Transport:**
- Read from stdin (JSON-RPC messages)
- Write to stdout (JSON-RPC responses)
- stderr para logs (não misturar com stdout)

### Coding Standards

[Source: architecture/coding-standards.md]

**Critical Rules:**
- TypeScript strict mode, no `any` types
- Always use async/await (não usar .then/.catch)
- Nunca usar console.log - usar Logger (pino)
- Input validation com Zod schemas
- Error handling: try/catch em async functions, custom error classes
- Dependency Injection via constructor
- TSDoc comments para public APIs

**Naming Conventions:**
- Classes: PascalCase (`McpServer`, `Logger`)
- Functions: camelCase (`initialize()`, `shutdown()`)
- Constants: UPPER_SNAKE_CASE (`MAX_RETRIES`, `DEFAULT_TIMEOUT`)
- Files: kebab-case (`mcp-server.ts`, `logger.ts`)

**Error Handling Pattern:**
```typescript
try {
  await riskyOperation();
} catch (error) {
  logger.error('Operation failed', { error, context: {...} });
  throw new CustomError('User-friendly message', { cause: error });
}
```

### Logging Standards

[Source: architecture/backend-architecture.md#Global Error Handling]

**Logger Singleton Pattern:**
```typescript
// src/core/logger.ts
import pino from 'pino';

export class Logger {
  private static instance: pino.Logger;
  
  static getInstance(): pino.Logger {
    if (!Logger.instance) {
      Logger.instance = pino({
        level: process.env.LOG_LEVEL || 'info',
        redact: ['*.access_token', '*.password'],
        formatters: {
          level: (label) => ({ level: label }),
        },
      });
    }
    return Logger.instance;
  }
}
```

**Log Structured Events:**
```typescript
logger.info('MCP Server started', {
  version: '1.0.0',
  bitbucket_url: config.bitbucket_url,
  transport: 'stdio',
});

logger.error('Request failed', {
  error: error.message,
  stack: error.stack,
  operation_id: 'create_issue',
  correlation_id: 'abc-123',
});
```

**Log Levels:**
- `debug`: Verbose diagnostic info
- `info`: Startup, shutdown, major events
- `warn`: Recoverable errors, deprecations
- `error`: Unrecoverable errors, exceptions

### Data Models

[Source: architecture/data-models.md]

**Config Interface:**
```typescript
interface Config {
  bitbucket_url: string;
  auth_method: 'oauth2' | 'pat' | 'oauth1' | 'basic';
  rate_limit: number;           // Default: 100
  timeout: number;              // Default: 30000
  log_level: 'debug' | 'info' | 'warn' | 'error';
  cache_size: number;           // Default: 1000
  retry_attempts: number;       // Default: 3
}
```

**Error Types:**
```typescript
class McpProtocolError extends Error {
  code: string;
  constructor(message: string, code: string) {
    super(message);
    this.code = code;
    this.name = 'McpProtocolError';
  }
}

class ConfigurationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'ConfigurationError';
  }
}
```

### Integration Test Strategy

[Source: architecture/testing-strategy.md#Integration Tests]

**MCP Protocol Test Approach:**
```typescript
// tests/integration/mcp-server.test.ts
import { spawn } from 'child_process';
import { describe, it, expect } from 'vitest';

describe('MCP Server Integration', () => {
  it('should start and respond to initialize request', async () => {
    // Spawn server process
    const server = spawn('node', ['dist/index.js']);
    
    // Send initialize request via stdin
    server.stdin.write(JSON.stringify({
      jsonrpc: '2.0',
      id: 1,
      method: 'initialize',
      params: { clientInfo: { name: 'test' } }
    }) + '\n');
    
    // Wait for response on stdout
    const response = await readJsonRpcResponse(server.stdout);
    
    expect(response.result.serverInfo.name).toBe('bitbucket-dc-mcp-server');
    
    // Cleanup
    server.kill();
  });
});
```

**Test Coverage Requirements:**
- Unit tests: ≥85% line coverage
- Integration tests: Critical paths 100%
- CI fails se coverage abaixo de 85%

### Testing

[Source: architecture/testing-strategy.md]

**Test Framework:**
- Vitest (Jest-compatible API)
- File locations:
  - Unit: `tests/unit/core/mcp-server.test.ts`
  - Integration: `tests/integration/mcp-server.test.ts`

**Test Execution:**
```bash
npm test                      # Run all tests
npm test mcp-server          # Run specific test file
npm run test:coverage        # Generate coverage report
```

**Test Strategy:**
- Unit tests: Mock dependencies (Logger, Config)
- Integration tests: Spawn real server process, test stdio communication
- Test error scenarios: invalid messages, timeout, crashes

**Coverage Targets:**
- Unit tests: ≥85% line coverage
- Integration tests: Happy path + error scenarios
- CI pipeline fails se coverage < 85%

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-16 | 1.0 | Initial story draft created | Bob (Scrum Master) |
| 2025-10-16 | 1.1 | Story approved and ready for development | Bob (Scrum Master) |
| 2025-10-16 | 1.2 | PO validation passed - story approved and ready for dev | Sarah (PO) |
| 2025-10-16 | 1.3 | Story validated - date corrections applied | AI Dev Agent |

## Dev Agent Record

_This section will be populated by the development agent during implementation._

### Agent Model Used

- GPT-5-Codex (GitHub Copilot)

### Debug Log References

- `npm run build`
- `npx vitest run tests/integration/mcp-server.test.ts tests/unit/mcp-server.test.ts`
- `node dist/index.js`

### Completion Notes List

- Added configurable stdio dependencies to `McpServer` to support in-memory transports during integration testing.
- Implemented runtime bootstrap in `src/index.ts` that loads config, configures logging, attaches signal/error handlers, and starts the MCP server.
- Created an integration test that simulates an MCP client handshake and verifies logging notifications travel through the server.
- Declared npm `start` script for running the compiled server entry point.
- Documented the MCP server class and lifecycle methods with TSDoc, including usage examples and return semantics.
- Added integration coverage to ensure malformed stdio frames trigger protocol error logging without crashing the server.
- Introduced unit tests that validate error handling and enforce graceful shutdown timeouts.
- Confirmed MCP SDK and pino dependencies, strict TypeScript configuration, and Node.js 22 compatibility for the MCP server build.
- Implemented the base `McpServer` class with stdio transport wiring, handshake lifecycle, and ready-state exposure.

### File List

- src/core/mcp-server.ts
- src/index.ts
- package.json
- tests/integration/mcp-server.test.ts
- tests/unit/mcp-server.test.ts

## QA Results

_This section will be populated by QA Agent after implementation review._

