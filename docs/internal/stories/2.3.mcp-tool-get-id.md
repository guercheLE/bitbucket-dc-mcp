# Story 2.3: MCP Tool: get_id

## Status

Ready for Review

## Story

**As a** LLM,  
**I want** MCP tool `get_id` que retorna schema completo, docs, e exemplos para Bitbucket operation ID,  
**so that** posso entender como usar a operation e gerar valid API call.

## Acceptance Criteria

1. Tool `get_id` registrado no MCP server com schema: input=(operation_id: string), output=(operation details object)
2. Tool lê metadata da operation de `data/operations.json` ou database
3. Tool retorna: operationId, path, method, summary, description, parameters (path/query/header/body), requestBody schema, responses, examples (curl command, request/response samples)
4. Tool inclui links para Bitbucket official docs quando disponível
5. Tool implementa validation: operation_id exists (retorna 404 error se não encontrado)
6. Tool formata output para ser LLM-readable: clear structure, code blocks para examples
7. Tool tem caching: results são cached (LRU, 500 entries) pois schemas raramente mudam
8. Integration test valida: tool returns complete schema para known operation IDs
9. Tool documenta example usage no MCP tools list

## Tasks / Subtasks

- [x] Task 1: Criar estrutura base do get_id tool (AC: 1)
  - [x] Criar arquivo `src/tools/get-id-tool.ts` seguindo project structure
  - [x] Definir interfaces TypeScript para GetIdInput e GetIdOutput
  - [x] Implementar Zod schema para input validation (operation_id: string não vazio)
  - [x] Adicionar TSDoc comments: @param, @returns, @example

- [x] Task 2: Integrar com EmbeddingsRepository para buscar operation metadata (AC: 2, 3)
  - [x] Injetar EmbeddingsRepository via constructor (dependency injection pattern)
  - [x] Implementar método `execute(input: GetIdInput): Promise<GetIdOutput>`
  - [x] Chamar `embeddingsRepository.getOperation(input.operation_id)`
  - [x] Mapear Operation model para GetIdOutput format incluindo todos os campos required
  - [x] Parse JSON fields (tags, parameters, requestBody, responses) armazenados como TEXT no database

- [x] Task 3: Gerar exemplos práticos de uso (AC: 3, 6)
  - [x] Criar método `generateExamples(operation: Operation): Examples`
  - [x] Gerar curl command example baseado em path, method, e parameters
  - [x] Extrair request example do requestBody.content.examples se disponível no OpenAPI spec
  - [x] Extrair response example do responses["200"].content.examples se disponível
  - [x] Formatar examples em code blocks markdown para LLM readability

- [x] Task 4: Adicionar links de documentação oficial (AC: 4)
  - [x] Implementar método `getDocumentationUrl(operation: Operation): string | undefined`
  - [x] Construir URL baseado em operation_id pattern: `https://developer.atlassian.com/server/bitbucket/rest/v1000/intro/`
  - [x] Incluir documentation_url no GetIdOutput quando disponível

- [x] Task 5: Implementar input validation e error handling (AC: 5)
  - [x] Validar operation_id com Zod: não vazio, tipo string
  - [x] Se operation não encontrado no database, retornar MCP error response 404
  - [x] Se operation encontrado mas deprecated, incluir warning no output
  - [x] Adicionar unit test: valid operation_id returns data, invalid returns 404 error

- [x] Task 6: Implementar LRU cache (AC: 7)
  - [x] Injetar CacheManager via constructor
  - [x] Configurar cache com max 500 entries e LRU eviction policy
  - [x] Cache key: operation_id
  - [x] Cache value: GetIdOutput completo
  - [x] Check cache antes de query database
  - [x] Adicionar cache hit/miss metrics para logging
  - [x] Unit test: cache hit após first call, cache respects LRU eviction

- [x] Task 7: Registrar tool no MCP Server (AC: 1, 9)
  - [x] Adicionar GetIdTool registration em `src/tools/register-tools.ts`
  - [x] Definir tool name: "get_id"
  - [x] Definir tool description para MCP tools list: "Get complete schema, documentation, and examples for a specific Bitbucket operation ID"
  - [x] Definir inputSchema usando Zod.toJsonSchema()
  - [x] Implementar tool handler que chama GetIdTool.execute()
  - [x] Adicionar logging: operation_id requested, cache hit/miss, latency

- [x] Task 8: Adicionar structured logging (AC: observability)
  - [x] Log início da request: operation_id, timestamp
  - [x] Log cache hit/miss
  - [x] Log se operation não encontrado (404)
  - [x] Log latency da operation (cache hit deve ser <1ms, database query <50ms)
  - [x] Log errors com contexto completo (operation_id, stack trace)

- [x] Task 9: Criar unit tests (AC: 8, coverage ≥85%)
  - [x] Test: valid operation_id returns complete GetIdOutput
  - [x] Test: invalid operation_id returns 404 MCP error
  - [x] Test: deprecated operation includes warning
  - [x] Test: examples são gerados corretamente (curl, request, response)
  - [x] Test: documentation URL é construída corretamente
  - [x] Test: cache hit após first call (mock CacheManager)
  - [x] Test: cache miss após eviction
  - [x] Test: Zod validation rejects empty operation_id

- [x] Task 10: Criar integration test (AC: 8)
  - [x] Setup: JsonOperationsRepository reading from operations.json
  - [x] Test: getOperation("move_issues_to_backlog") returns complete schema
  - [x] Test: getOperation("get_all_boards") returns complete schema
  - [x] Test: getOperation("nonexistent_operation") returns 404 error
  - [x] Assert: path, method, parameters, requestBody, responses present
  - [x] Assert: examples include curl, request, response
  - [x] Assert: documentation_url is valid URL

## Dev Notes

### Previous Story Insights

- **História 2.1** implementou a base do MCP Server com stdio transport e tool registration
- **História 2.2** implementou o primeiro tool (search_ids) com padrões de:
  - Dependency injection (services via constructor)
  - Input validation com Zod
  - Error handling consistente com MCP error responses
  - Structured logging com pino
  - Unit e integration tests com Vitest
- Esta história deve seguir os mesmos padrões estabelecidos

### Data Models

[Source: architecture/data-models.md#Operation]

**Operation Model:**
```typescript
interface Operation {
  operation_id: string;
  path: string;
  method: HttpMethod; // 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH'
  summary: string;
  description: string;
  tags: string[];
  parameters: Parameter[];
  requestBody: RequestBody | null;
  responses: Record<string, Response>;
  deprecated: boolean;
  security: SecurityRequirement[];
}

interface Parameter {
  name: string;
  in: 'path' | 'query' | 'header' | 'cookie';
  required: boolean;
  schema: JsonSchema;
  description?: string;
}

interface RequestBody {
  required: boolean;
  content: Record<string, MediaType>;
}

interface MediaType {
  schema: JsonSchema;
  examples?: Record<string, Example>;
}
```

### API Specifications

[Source: architecture/api-specification.md#Tool: get_id]

**Tool Input Schema:**
```typescript
interface GetIdInput {
  operation_id: string; // Required
}
```

**Tool Output Schema:**
```typescript
interface GetIdOutput {
  operation_id: string;
  path: string;
  method: string;
  summary: string;
  description: string;
  parameters: Parameter[];
  requestBody?: RequestBody;
  responses: Record<string, Response>;
  examples: {
    curl: string;
    request: any;
    response: any;
  };
  documentation_url?: string;
}
```

### Database Access

[Source: architecture/database-schema.md]
[Source: architecture/backend-architecture.md#Data Access Layer]

**Database Table:**
```sql
CREATE TABLE operations (
    operation_id TEXT PRIMARY KEY,
    path TEXT NOT NULL,
    method TEXT NOT NULL,
    summary TEXT NOT NULL,
    description TEXT,
    tags TEXT, -- JSON array
    parameters TEXT, -- JSON array
    request_body TEXT, -- JSON
    responses TEXT, -- JSON
    deprecated INTEGER DEFAULT 0,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP
);
```

**Repository Method:**
```typescript
// src/data/embeddings-repository.ts
class EmbeddingsRepository {
  getOperation(operationId: string): Operation | null {
    const stmt = this.db.prepare(`
      SELECT * FROM operations WHERE operation_id = ?
    `);
    
    const row = stmt.get(operationId);
    if (!row) return null;
    
    return {
      operation_id: row.operation_id,
      path: row.path,
      method: row.method,
      summary: row.summary,
      description: row.description,
      tags: JSON.parse(row.tags),
      parameters: JSON.parse(row.parameters),
      requestBody: row.request_body ? JSON.parse(row.request_body) : null,
      responses: JSON.parse(row.responses),
    };
  }
}
```

### File Locations

[Source: architecture/unified-project-structure.md]

**Source Files:**
- Tool implementation: `src/tools/get-id-tool.ts`
- Tool registration: `src/core/mcp-server.ts` (add to existing registerTools method)
- Repository: `src/data/embeddings-repository.ts` (use existing getOperation method)
- Cache: `src/core/cache-manager.ts` (use existing LRU cache implementation)

**Test Files:**
- Unit tests: `tests/unit/tools/get-id-tool.test.ts`
- Integration tests: `tests/integration/get-id-integration.test.ts`

### Caching Strategy

[Source: architecture/data-models.md#Config]

**CacheManager Configuration:**
- Max entries: 500 (configurável via Config)
- Eviction policy: LRU (Least Recently Used)
- Cache key: operation_id
- Cache value: GetIdOutput completo
- TTL: Infinity (schemas raramente mudam)

**Implementation Pattern:**
```typescript
class GetIdTool {
  constructor(
    private repository: EmbeddingsRepository,
    private cache: CacheManager,
    private logger: Logger
  ) {}
  
  async execute(input: GetIdInput): Promise<GetIdOutput> {
    // Check cache first
    const cached = this.cache.get(input.operation_id);
    if (cached) {
      this.logger.debug('Cache hit', { operation_id: input.operation_id });
      return cached;
    }
    
    // Query database
    const operation = this.repository.getOperation(input.operation_id);
    if (!operation) {
      throw new OperationNotFoundError(input.operation_id);
    }
    
    // Transform and cache
    const output = this.transformToOutput(operation);
    this.cache.set(input.operation_id, output);
    
    return output;
  }
}
```

### Error Handling

[Source: architecture/coding-standards.md#Error Handling]

**Custom Error Classes:**
```typescript
class OperationNotFoundError extends Error {
  constructor(operationId: string) {
    super(`Operation '${operationId}' not found`);
    this.name = 'OperationNotFoundError';
  }
}
```

**MCP Error Response Format:**
```typescript
// Se operation não encontrado, retornar MCP error:
{
  error: {
    code: 'OPERATION_NOT_FOUND',
    message: "Operation 'invalid_operation' not found",
    data: {
      operation_id: 'invalid_operation',
      available_operations_count: 500
    }
  }
}
```

### Technical Constraints

[Source: architecture/tech-stack.md]

- **Runtime:** Node.js 22+ LTS
- **Language:** TypeScript 5.x strict mode
- **Validation:** Zod 3.x para input schemas
- **Database:** better-sqlite3 (synchronous API)
- **Cache:** LRU cache (implementação custom ou `lru-cache` library)
- **Logging:** pino 8.x structured JSON logs
- **Testing:** Vitest (Jest-compatible API)

### Performance Considerations

- Cache hit latency target: <1ms
- Database query latency target: <50ms
- Tool execution total latency target: <100ms (99th percentile)
- Memory usage: Cache limited to 500 entries (~2-3MB assuming ~5KB per operation)

### Security Considerations

[Source: architecture/coding-standards.md]

- Input validation: Zod schema rejects empty/invalid operation_ids
- No sensitive data in logs: operation_id e metadata são safe para logging
- No SQL injection: Usar prepared statements (better-sqlite3 `.prepare()`)
- Read-only database: Não permite modifications em runtime

## Testing

[Source: architecture/testing-strategy.md]

### Unit Test Structure

**Framework:** Vitest com vi.fn() para mocks  
**Coverage target:** ≥85% line coverage  
**Test pattern:** describe/it blocks, beforeEach setup, expect assertions

**Unit Test Structure:**
```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { GetIdTool } from '../../../src/tools/get-id-tool.js';
import { EmbeddingsRepository } from '../../../src/data/embeddings-repository.js';

describe('GetIdTool', () => {
  let tool: GetIdTool;
  let mockRepository: vi.Mocked<EmbeddingsRepository>;
  let mockCache: vi.Mocked<CacheManager>;
  let mockLogger: vi.Mocked<Logger>;
  
  beforeEach(() => {
    mockRepository = {
      getOperation: vi.fn(),
    } as any;
    
    mockCache = {
      get: vi.fn(),
      set: vi.fn(),
    } as any;
    
    mockLogger = {
      debug: vi.fn(),
      info: vi.fn(),
      error: vi.fn(),
    } as any;
    
    tool = new GetIdTool(mockRepository, mockCache, mockLogger);
  });
  
  it('should return operation details from cache if available', async () => {
    const cachedOutput = {
      operation_id: 'create_issue',
      path: '/rest/api/3/issue',
      method: 'POST',
      // ... resto dos campos
    };
    
    mockCache.get.mockReturnValue(cachedOutput);
    
    const result = await tool.execute({ operation_id: 'create_issue' });
    
    expect(result).toEqual(cachedOutput);
    expect(mockCache.get).toHaveBeenCalledWith('create_issue');
    expect(mockRepository.getOperation).not.toHaveBeenCalled();
    expect(mockLogger.debug).toHaveBeenCalledWith('Cache hit', { operation_id: 'create_issue' });
  });
  
  it('should query database on cache miss and cache result', async () => {
    mockCache.get.mockReturnValue(null);
    mockRepository.getOperation.mockReturnValue({
      operation_id: 'create_issue',
      path: '/rest/api/3/issue',
      method: 'POST',
      summary: 'Create issue',
      // ... resto dos campos
    });
    
    const result = await tool.execute({ operation_id: 'create_issue' });
    
    expect(result.operation_id).toBe('create_issue');
    expect(mockRepository.getOperation).toHaveBeenCalledWith('create_issue');
    expect(mockCache.set).toHaveBeenCalledWith('create_issue', expect.any(Object));
  });
  
  it('should throw OperationNotFoundError if operation does not exist', async () => {
    mockCache.get.mockReturnValue(null);
    mockRepository.getOperation.mockReturnValue(null);
    
    await expect(tool.execute({ operation_id: 'nonexistent' }))
      .rejects.toThrow('Operation \'nonexistent\' not found');
  });
});
```

### Integration Test Requirements

- Setup: Real sqlite-vec database com sample embeddings
- Mock MCP client para simular stdio transport
- Validar tool registration no MCP Server
- Test operation IDs: "create_issue", "update_issue_assignee", "get_project"
- Assert: operation_id, path, method, summary, parameters, requestBody, responses, examples format corretos

### Key Implementation Steps

1. Definir Zod schema para GetIdInput validation
2. Implementar GetIdTool class com execute() method
3. Integrar com EmbeddingsRepository.getOperation() via dependency injection
4. Implementar cache check/set usando CacheManager
5. Implementar generateExamples() para criar curl command e samples
6. Implementar getDocumentationUrl() para Bitbucket docs links
7. Implementar structured logging (início, cache hit/miss, erros)
8. Registrar tool no MCP Server com inputSchema e handler
9. Criar unit tests com mocks
10. Criar integration test com real database

### Performance Considerations

- Cache hit deve ser <1ms (in-memory lookup)
- Database query deve ser <50ms (SQLite index lookup)
- Examples generation deve ser <5ms (string formatting)
- Total tool latency target: <100ms (99th percentile)

### Security Considerations

- Input validation previne empty/malformed operation_ids
- Database é read-only (no modification risks)
- Logs não devem expor dados sensíveis (operation metadata é safe)
- No SQL injection (prepared statements)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-16 | 1.0 | Initial story creation for MCP Tool: get_id | Bob (Scrum Master) |
| 2025-10-16 | 1.1 | Story approved and ready for development | Bob (Scrum Master) |
| 2025-10-16 | 1.2 | PO validation passed - story approved and ready for dev | Sarah (PO) |
| 2025-10-16 | 1.3 | Story validated - date corrections applied | AI Dev Agent |
| 2025-10-18 | 2.0 | Implementation completed - all tasks and tests passing | James (Dev Agent) |

## Dev Agent Record

### Agent Model Used

Claude 3.5 Sonnet (claude-3-5-sonnet-20241022)

### Debug Log References

_Not yet implemented_

### Completion Notes List

- ✅ Implemented GetIdTool with complete TypeScript interfaces and Zod validation
- ✅ Created JsonOperationsRepository for reading operation metadata from operations.json
- ✅ Integrated QueryCache with 500 entry limit and infinite TTL for operation details
- ✅ Generated practical examples including curl commands, request/response samples
- ✅ Implemented documentation URL generation for Bitbucket API and Agile API operations
- ✅ Added comprehensive structured logging with cache hit/miss, latency tracking, and error context
- ✅ Registered get_id tool in MCP server via register-tools.ts
- ✅ Created 23 unit tests with 100% pass rate covering all edge cases
- ✅ Created 11 integration tests using real operations.json data
- ✅ All tests pass (113 passed, 1 skipped, 34 total test suites)
- ✅ Zero linting errors
- ⚠️ Note: Tool registration signature updated in register-tools.ts to accept operationsRepository parameter

### File List

**Source Files (New):**
- `src/tools/get-id-tool.ts` - Main GetIdTool implementation with interfaces, validation, caching
- `src/data/operations-repository.ts` - JsonOperationsRepository for reading operations.json

**Source Files (Modified):**
- `src/tools/register-tools.ts` - Added get_id tool registration and handler

**Test Files (New):**
- `tests/unit/tools/get-id-tool.test.ts` - 23 unit tests for GetIdTool
- `tests/integration/get-id-integration.test.ts` - 11 integration tests

**Story File (Modified):**
- `docs/stories/2.3.mcp-tool-get-id.md` - Task checkboxes updated, completion notes added

## QA Results

_Pending implementation and QA review_

