# Story 1.2: OpenAPI Spec Download & Parsing

## Status

Approved

## Story

**As a** developer,  
**I want** script que download Bitbucket DC OpenAPI spec 11.0.1 e parse para extrair operations e schemas,  
**so that** tenho source of truth para todos os endpoints Bitbucket que vou suportar via MCP.

## Acceptance Criteria

1. Script `scripts/download-openapi.ts` faz download de Bitbucket DC REST API OpenAPI spec (JSON format) da URL oficial ou local file
2. Spec é validado como valid OpenAPI 3.0+ usando biblioteca de validação
3. Script extrai lista de operations com: operationId, path, method, summary, description, parameters, requestBody, responses
4. Script normaliza operationIds para formato consistente (ex: `issues-createIssue` → `create_issue`)
5. Extracted operations são salvos em `data/operations.json` (intermediário, commit no repo)
6. Extracted schemas (components/schemas) são salvos em `data/schemas.json`
7. Script tem error handling robusto (network failures, invalid spec, missing fields)
8. Unit tests cobrem parsing logic com mock OpenAPI specs

## Tasks / Subtasks

- [x] Task 1: Criar estrutura do script de download (AC: 1, 7)
  - [x] Criar arquivo `scripts/download-openapi.ts`
  - [x] Instalar dependências: `npm install --save-dev openapi3-ts node-fetch@3`
  - [x] Configurar constantes: `OPENAPI_SPEC_URL`, `OPENAPI_LOCAL_PATH`, `OUTPUT_DIR`
  - [x] Implementar função `downloadSpec(url: string): Promise<string>` com error handling
  - [x] Implementar função `loadLocalSpec(path: string): Promise<string>` com error handling
  - [x] Adicionar CLI arguments parsing: `--url` ou `--local` flags
  - [x] Implementar progress indicators usando console.log (temporário, será substituído por logger em stories futuras)

- [x] Task 2: Implementar validação OpenAPI (AC: 2)
  - [x] Criar função `validateOpenAPISpec(spec: any): Promise<boolean>`
  - [x] Verificar `openapi` version field (deve ser 3.0.x ou 3.1.x)
  - [x] Verificar estrutura obrigatória: `info`, `paths`, `components`
  - [x] Lançar erro descritivo se spec inválida
  - [x] Log validation success com version info

- [x] Task 3: Extrair operations do spec (AC: 3)
  - [x] Criar função `extractOperations(spec: OpenAPIDocument): Operation[]`
  - [x] Iterar sobre `spec.paths[path][method]` (GET, POST, PUT, DELETE, PATCH)
  - [x] Para cada operation, extrair campos obrigatórios:
    ```typescript
    {
      operationId: string,
      path: string,
      method: string,
      summary: string,
      description: string | undefined,
      tags: string[],
      parameters: ParameterObject[],
      requestBody: RequestBodyObject | undefined,
      responses: Record<string, ResponseObject>
    }
    ```
  - [x] Filtrar operations deprecated: skip se `deprecated: true`
  - [x] Adicionar validação: skip operations sem operationId
  - [x] Log número total de operations extraídas

- [x] Task 4: Normalizar operationIds (AC: 4)
  - [x] Criar função `normalizeOperationId(operationId: string): string`
  - [x] Implementar regras de normalização:
    - Converter para snake_case: `issuesCreateIssue` → `issues_create_issue`
    - Remover prefixos redundantes: `issues-createIssue` → `create_issue`
    - Substituir hífens por underscores: `get-issue-id` → `get_issue_id`
    - Converter para lowercase
  - [x] Adicionar unit tests para normalização:
    - `"issuesCreateIssue"` → `"create_issue"`
    - `"get-issue-watchers"` → `"get_issue_watchers"`
    - `"projectsGetAllProjects"` → `"get_all_projects"`
  - [x] Validar uniqueness: lançar erro se operationIds duplicados após normalização

- [x] Task 5: Extrair schemas (AC: 6)
  - [x] Criar função `extractSchemas(spec: OpenAPIDocument): Record<string, SchemaObject>`
  - [x] Extrair todos os schemas de `spec.components.schemas`
  - [x] Preservar schema completo incluindo:
    - `type`, `properties`, `required`, `description`
    - `enum`, `allOf`, `oneOf`, `anyOf` (para Zod generation posterior)
    - `format`, `minLength`, `maxLength`, `minimum`, `maximum`
  - [x] Resolver $ref references recursivamente (apenas 1 nível para MVP)
  - [x] Log número de schemas extraídos

- [x] Task 6: Salvar outputs em JSON (AC: 5, 6)
  - [x] Criar função `saveOperations(operations: Operation[], outputPath: string): Promise<void>`
  - [x] Criar função `saveSchemas(schemas: Record<string, SchemaObject>, outputPath: string): Promise<void>`
  - [x] Garantir diretório `data/` existe antes de salvar
  - [x] Salvar `operations.json` formatado com Prettier (indentação 2 espaços)
  - [x] Salvar `schemas.json` formatado com Prettier
  - [x] Adicionar metadados no header:
    ```json
    {
      "_metadata": {
        "generated_at": "2025-01-15T10:30:00Z",
        "openapi_version": "3.0.1",
        "bitbucket_version": "11.0.1",
        "total_operations": 523,
        "total_schemas": 187
      },
      "operations": [...]
    }
    ```
  - [x] Log caminho completo dos arquivos salvos

- [x] Task 7: Implementar error handling robusto (AC: 7)
  - [x] Adicionar try/catch em todas as funções async
  - [x] Implementar custom error classes:
    ```typescript
    class NetworkError extends Error { constructor(url: string, cause: Error) }
    class ValidationError extends Error { constructor(message: string, details: any) }
    class ParsingError extends Error { constructor(field: string, cause: Error) }
    ```
  - [x] Adicionar mensagens descritivas para cada tipo de erro
  - [x] Log stack traces em errors (temporário console.error, será logger depois)
  - [x] Exit process com código 1 em caso de erro fatal

- [x] Task 8: Adicionar CLI execution e package.json script (AC: 1)
  - [x] Adicionar script no package.json:
    ```json
    {
      "scripts": {
        "download-openapi": "tsx scripts/download-openapi.ts"
      }
    }
    ```
  - [x] Instalar tsx: `npm install --save-dev tsx` (TypeScript execution)
  - [x] Adicionar help flag: `--help` mostra usage instructions:
    ```
    Usage: npm run download-openapi [options]
    
    Download and parse Bitbucket Data Center OpenAPI specification
    
    Options:
      --url <url>      Download OpenAPI spec from URL (default: Bitbucket Cloud spec)
      --local <path>   Use local OpenAPI spec file (for air-gapped environments)
      --help           Show this help message
    
    Examples:
      npm run download-openapi
      npm run download-openapi -- --url https://example.com/openapi.json
      npm run download-openapi -- --local ./downloaded-spec.json
    
    Output:
      data/operations.json - Parsed operations metadata
      data/schemas.json    - Extracted OpenAPI schemas
    ```
  - [x] Adicionar exemplo de uso no README.md do projeto

- [x] Task 9: Criar unit tests (AC: 8)
  - [x] Criar `tests/unit/scripts/download-openapi.test.ts`
  - [x] Mock OpenAPI spec válido (mínimo: 5 operations, 3 schemas)
  - [x] Test case: `validateOpenAPISpec()` aceita spec válida
  - [x] Test case: `validateOpenAPISpec()` rejeita spec inválida (missing paths)
  - [x] Test case: `extractOperations()` extrai campos corretamente
  - [x] Test case: `extractOperations()` filtra deprecated operations
  - [x] Test case: `normalizeOperationId()` aplica transformações corretas
  - [x] Test case: `normalizeOperationId()` detecta duplicatas
  - [x] Test case: `extractSchemas()` extrai todos os schemas
  - [x] Test case: `extractSchemas()` resolve $ref references
  - [x] Mock node-fetch para testar download failures
  - [x] Executar `npm test` e garantir 100% coverage para parsing logic

- [x] Task 10: Validar end-to-end com spec real
  - [x] Executar `npm run download-openapi -- --url https://dac-static.atlassian.com/server/bitbucket/10.0.swagger.v3.json?_v=1.637.23`
  - [x] Verificar `data/operations.json` criado com ~500+ operations
  - [x] Verificar `data/schemas.json` criado com ~180+ schemas
  - [x] Inspecionar manualmente 5 operations aleatórias: campos completos?
  - [x] Inspecionar manualmente 3 schemas aleatórios: estrutura preservada?
  - [x] Verificar normalização: nenhum operationId com hífen ou camelCase
  - [x] Commit `data/operations.json` e `data/schemas.json` no repo (são source of truth)

## Dev Notes

### Previous Story Context

**Story 1.1 - Project Initialization:**
- Estrutura de projeto TypeScript configurada com build scripts
- Testing framework Vitest configurado e funcionando
- ESLint e Prettier configurados
- CI/CD pipeline GitHub Actions operacional
- Entry point `src/index.ts` criado (placeholder, será usado em stories futuras)

### OpenAPI Processing Requirements

[Source: docs/prd/epic-1-foundation-semantic-search-engine.md#story-1.2]

Esta história é o primeiro passo para semantic search: baixar e processar o OpenAPI spec da Bitbucket Data Center REST API v3 (versão 11.0.1).

**Objetivo:** Criar arquivo intermediário `data/operations.json` com metadados estruturados de ~500 operations Bitbucket que serão usados para:
- Story 1.3: Gerar schemas Zod para validação runtime
- Story 1.4: Gerar embeddings vetoriais para semantic search
- Story 1.5+: Indexar no sqlite-vec database

**OpenAPI Spec Source:**
- URL: https://dac-static.atlassian.com/server/bitbucket/10.0.swagger.v3.json?_v=1.637.23 (ou local file para air-gapped)
- Versão: OpenAPI 3.0.1
- Bitbucket Version: 11.0.1 (Data Center REST API v3)
- Tamanho: ~15MB JSON (500+ operations, 180+ schemas)

### Tech Stack Specifics

[Source: docs/architecture/tech-stack.md]

**Bibliotecas para esta história:**
- `openapi3-ts`: TypeScript types para OpenAPI 3.x spec parsing (melhor que JSON parsing manual)
- `node-fetch@3`: Download HTTP com native Node.js fetch API (Node 22+)
- `tsx`: TypeScript execution para scripts (evita compilação manual)

**Rationale - Por que não usar bibliotecas third-party de OpenAPI validation complexas:**
- Swagger Parser seria overkill (bundle size grande, muitas features desnecessárias)
- Custom validation é suficiente: apenas verificar estrutura básica (OpenAPI 3.x, paths exist)
- Reduced dependencies = menos vulnerabilidades, faster npm install

### Project Structure

[Source: docs/architecture/unified-project-structure.md]

**Localização dos arquivos:**
```
scripts/
└── download-openapi.ts    # Este script (novo)
data/
├── operations.json         # Output 1 (commit no repo)
└── schemas.json            # Output 2 (commit no repo)
tests/unit/scripts/
└── download-openapi.test.ts # Unit tests (novo)
```

**Key Decision:** `data/operations.json` e `data/schemas.json` **SÃO commitados** no repositório (diferente de `data/embeddings.db` que é gitignored). Rationale:
- São source of truth derivados do OpenAPI spec externo
- Facilitam reprodutibilidade: developers podem gerar embeddings sem re-download spec
- Permitem code review de mudanças quando OpenAPI spec atualiza
- Tamanho pequeno: ~1-2MB comprimidos no Git

### OpenAPI Normalization Strategy

[Source: docs/prd/epic-1-foundation-semantic-search-engine.md#story-1.2, AC4]

**operationId Normalization Rules:**

1. **Remove prefixos redundantes:** Bitbucket OpenAPI spec usa prefixos namespace como `issues-`, `projects-`, `users-`. Remover para simplificar.
   - Input: `"issues-createIssue"`
   - Output: `"create_issue"`

2. **Convert camelCase to snake_case:** MCP tools preferem snake_case para consistency.
   - Input: `"getIssueWatchers"`
   - Output: `"get_issue_watchers"`

3. **Replace hyphens with underscores:**
   - Input: `"get-issue-id"`
   - Output: `"get_issue_id"`

4. **Lowercase everything:**
   - Input: `"CreateIssue"`
   - Output: `"create_issue"`

**Validation:** Após normalização, verificar uniqueness. Se dois operationIds diferentes resultarem no mesmo normalizado, lançar erro e solicitar review manual.

### Error Handling Strategy

[Source: docs/architecture/coding-standards.md]

**Custom Error Classes (criar em script):**
```typescript
class NetworkError extends Error {
  constructor(url: string, cause: Error) {
    super(`Failed to download OpenAPI spec from ${url}: ${cause.message}`);
    this.name = 'NetworkError';
    this.cause = cause;
  }
}

class ValidationError extends Error {
  constructor(message: string, details?: any) {
    super(`OpenAPI validation failed: ${message}`);
    this.name = 'ValidationError';
    this.details = details;
  }
}

class ParsingError extends Error {
  constructor(field: string, cause: Error) {
    super(`Failed to parse field '${field}': ${cause.message}`);
    this.name = 'ParsingError';
    this.cause = cause;
  }
}
```

**Error Handling Pattern:**
```typescript
try {
  const spec = await downloadSpec(url);
  const operations = extractOperations(spec);
  await saveOperations(operations, 'data/operations.json');
} catch (error) {
  if (error instanceof NetworkError) {
    console.error('Network error:', error.message);
    console.error('Check internet connection or try --local flag');
  } else if (error instanceof ValidationError) {
    console.error('Validation error:', error.message);
    console.error('Details:', error.details);
  } else {
    console.error('Unexpected error:', error);
  }
  process.exit(1);
}
```

**Rationale:** Custom error classes permitem error handling granular e mensagens user-friendly para CLI.

### Coding Standards

[Source: docs/architecture/coding-standards.md]

**Aplicáveis a esta história:**
- **Type Safety:** Usar `openapi3-ts` types (OpenAPIV3.Document, PathItemObject, OperationObject)
- **No Console.log:** Temporariamente permitido nesta história (logger pino será introduzido em Story 1.x+), mas minimizar uso
- **Async/Await:** Todas as funções I/O (download, file read/write) devem ser async
- **Immutability:** Usar const, nunca let. Usar Array.map() ao invés de mutations
- **Error Handling:** Sempre try/catch em async functions, never swallow errors
- **Test Coverage:** 100% coverage para parsing logic (crítico para data integrity)

### Testing Requirements

[Source: docs/architecture/testing-strategy.md]

**Test Organization:**
```
tests/unit/scripts/
└── download-openapi.test.ts
```

**Test Coverage Requirements:**
- Parser logic: 100% (crítico, pois erros propagam para embeddings)
- Network code: Mock com vi.mock('node-fetch')
- File I/O: Mock com vi.mock('fs/promises')

**Mock OpenAPI Spec (minimal válido para tests):**
```typescript
const mockOpenAPISpec = {
  openapi: '3.0.1',
  info: { title: 'Bitbucket API', version: '11.0.1' },
  paths: {
    '/rest/api/3/issue': {
      post: {
        operationId: 'issues-createIssue',
        summary: 'Create issue',
        description: 'Creates an issue',
        tags: ['Issues'],
        parameters: [],
        requestBody: { content: { 'application/json': { schema: { $ref: '#/components/schemas/IssueUpdateDetails' } } } },
        responses: { '201': { description: 'Created' } },
      },
    },
  },
  components: {
    schemas: {
      IssueUpdateDetails: {
        type: 'object',
        properties: {
          fields: { type: 'object' },
        },
        required: ['fields'],
      },
    },
  },
};
```

**Test Cases (mínimo):**
1. `validateOpenAPISpec()` aceita spec válida
2. `validateOpenAPISpec()` rejeita spec sem `paths`
3. `validateOpenAPISpec()` rejeita spec sem `openapi` version field
4. `extractOperations()` extrai operation_id, path, method corretos
5. `extractOperations()` filtra operations com `deprecated: true`
6. `normalizeOperationId('issues-createIssue')` retorna `'create_issue'`
7. `normalizeOperationId('getIssueWatchers')` retorna `'get_issue_watchers'`
8. `extractSchemas()` extrai schema com propriedades corretas
9. Network failure lança `NetworkError` com mensagem descritiva
10. File write failure lança error apropriado

**Test Execution:**
```bash
npm test -- tests/unit/scripts/download-openapi.test.ts
```

### TypeScript Types (usar openapi3-ts)

```typescript
import { OpenAPIV3 } from 'openapi3-ts';

type OpenAPIDocument = OpenAPIV3.Document;
type PathItemObject = OpenAPIV3.PathItemObject;
type OperationObject = OpenAPIV3.OperationObject;
type SchemaObject = OpenAPIV3.SchemaObject;
type ParameterObject = OpenAPIV3.ParameterObject;
type RequestBodyObject = OpenAPIV3.RequestBodyObject;
type ResponseObject = OpenAPIV3.ResponseObject;

// Custom types para output
interface Operation {
  operationId: string;
  path: string;
  method: string;
  summary: string;
  description?: string;
  tags: string[];
  parameters: ParameterObject[];
  requestBody?: RequestBodyObject;
  responses: Record<string, ResponseObject>;
  deprecated?: boolean;
}

interface OperationsOutput {
  _metadata: {
    generated_at: string;
    openapi_version: string;
    bitbucket_version: string;
    total_operations: number;
    total_schemas: number;
  };
  operations: Operation[];
}
```

### Environment Variables & Configuration

Esta história não requer environment variables em runtime, mas o script aceita configurações via CLI flags.

**CLI Configuration:**

| Flag | Type | Default | Description | Example |
|------|------|---------|-------------|---------|
| `--url` | string | `https://dac-static.atlassian.com/server/bitbucket/10.0.swagger.v3.json?_v=1.637.23` | URL para download do OpenAPI spec | `--url https://example.com/spec.json` |
| `--local` | string | none | Path para arquivo OpenAPI local (air-gapped) | `--local ./openapi.json` |
| `--help` | boolean | false | Mostra help message e sai | `--help` |

**Default Behavior:** Se nenhum flag fornecido, usa `--url` com default URL.

**Validation:** Script valida que apenas um de `--url` ou `--local` é fornecido (mutually exclusive).

### External API Integration Notes

[Source: docs/architecture/external-apis.md]

**Bitbucket Data Center OpenAPI Spec:**
- URL: https://dac-static.atlassian.com/server/bitbucket/10.0.swagger.v3.json?_v=1.637.23
- Formato: JSON (não YAML)
- Versão: OpenAPI 3.0.1
- Tamanho: ~15MB
- Nota: URL é para Bitbucket Server spec, compatível com Bitbucket DC 10.x+

**Alternative Local Path:** Para air-gapped environments, permitir `--local ./openapi.json` flag.

**Network Error Handling:**
- Timeout: 30 segundos para download
- Retries: 3x com exponential backoff (1s, 2s, 4s)
- User-friendly error: "Could not download OpenAPI spec. Try --local flag with downloaded file."

### Package.json Dependencies

```json
{
  "devDependencies": {
    "openapi3-ts": "^4.1.2",
    "tsx": "^4.7.0"
  }
}
```

**Rationale:**
- `openapi3-ts`: Provides TypeScript types for OpenAPI 3.x (não validation library, apenas types)
- `tsx`: Executar TypeScript diretamente sem compilação (ideal para scripts)

### Example CLI Usage

```bash
# Download from URL (default)
npm run download-openapi

# Download from specific URL
npm run download-openapi -- --url https://example.com/openapi.json

# Use local file (air-gapped)
npm run download-openapi -- --local ./downloaded-spec.json

# Show help
npm run download-openapi -- --help
```

### Success Criteria Validation

Após Task 10, validar:
- [x] `data/operations.json` existe com ~500+ operations
- [x] `data/schemas.json` existe com ~180+ schemas
- [x] Todos os operationIds estão normalizados (snake_case, lowercase, sem prefixos)
- [x] Nenhum operation deprecated incluído
- [x] Schemas preservam estrutura OpenAPI (type, properties, required)
- [x] Unit tests passam com 100% coverage
- [x] Script executa sem erros com spec real

## Testing

### Test File Location

[Source: docs/architecture/testing-strategy.md]

- Test file: `tests/unit/scripts/download-openapi.test.ts`
- Naming: `*.test.ts` suffix
- Organization: Espelha structure de `scripts/`

### Test Standards

- Framework: Vitest
- Coverage provider: v8
- Minimum coverage: 100% para parsing logic (esta história é data-critical)
- Mock external dependencies: node-fetch, fs/promises

### Testing Frameworks and Patterns

- Vitest API: `describe`, `it`, `expect`, `beforeEach`, `vi.mock()`
- Imports: usar `.js` extension (ESM requirement)
- Mocking: `vi.fn()` para funções, `vi.mocked()` para modules

### Specific Testing Requirements for Story 1.2

1. **Mock OpenAPI Spec (minimal):** Create mock spec com 5 operations, 3 schemas
2. **Parser Tests:** Validate extraction logic funciona corretamente
3. **Normalization Tests:** Validate operationId transformations
4. **Error Handling Tests:** Validate custom errors são lançados com mensagens corretas
5. **Network Mock:** Use `vi.mock('node-fetch')` para simular download failures
6. **File I/O Mock:** Use `vi.mock('fs/promises')` para simular write failures

**Test Execution:**
```bash
# Run only this story's tests
npm test -- tests/unit/scripts/download-openapi.test.ts

# Run with coverage
npm run test:coverage -- tests/unit/scripts/download-openapi.test.ts

# Watch mode during development
npm test -- --watch tests/unit/scripts/download-openapi.test.ts
```

**Coverage Assertion:** CI deve falhar se coverage < 100% para `scripts/download-openapi.ts`.

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-15 | 1.0 | Initial story creation | Bob (Scrum Master) |
| 2025-01-15 | 1.1 | Added Environment Variables section, CLI help text example, Status changed to Approved | Bob (Scrum Master) |
| 2025-10-16 | 1.2 | Story validation completed: All ACs covered, implementation-ready, 10/10 readiness score | Sarah (Product Owner) |
| 2025-10-16 | 1.3 | Re-validation completed: All 8 ACs properly covered, OpenAPI parsing logic validated, normalization strategy confirmed, error handling robust. Implementation Readiness Score: 10/10. Status: APPROVED | GitHub Copilot (AI Assistant) |

## Dev Agent Record

_This section will be populated by the development agent during implementation._

### Agent Model Used

- GPT-5-Codex (GitHub Copilot)

### Debug Log References

- 2025-10-17T02:11Z — `npm test`
- 2025-10-17T02:11Z — `npm run download-openapi`

### Completion Notes List

- Implemented TypeScript CLI to download, validate, and parse the Bitbucket OpenAPI spec with custom error handling and metadata-rich JSON outputs.
- Added comprehensive unit tests covering validation, normalization, extraction logic, and network error scenarios.
- Documented usage in `README.md` and generated committed artifacts `data/operations.json` and `data/schemas.json` from the live spec.

### File List

- scripts/download-openapi.ts
- tests/unit/scripts/download-openapi.test.ts
- package.json
- package-lock.json
- README.md
- data/operations.json
- data/schemas.json

## QA Results

_This section will be populated by QA Agent after story implementation is complete._

